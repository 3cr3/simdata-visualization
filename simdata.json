{
    "_add_base_codes": "METHOD: None",
    "_add_compartment_keys": "METHOD: None",
    "_add_condition_data": "METHOD: None",
    "_add_molecular_weight_keys": "METHOD: None",
    "adjust_final_expression": "METHOD: None",
    "adjust_new_gene_final_expression": "METHOD:  Adjusting the final expression values of new genes must be handled separately because the baseline new gene expression values need to be set to small non-zero values using data loaded from flat/new_gene_data/new_gene_baseline_expression_parameters.tsv, as new genes are knocked out by default. Args: gene_indices: Indices of new genes to adjust factors: Multiplicative factor to adjust by ",
    "adjustments": {
        "_add_adjustments": "METHOD: None",
        "balanced_translation_efficiencies": "LIST of length 4 of LIST types.",
        "protein_deg_rates_adjustments": "DICT of length 1 with STR, FLOAT key, value pairs.",
        "relative_metabolite_concentrations_changes": "DICT of length 1 with STR, DICT key, value pairs.",
        "rna_deg_rates_adjustments": "DICT of length 3 with STR, INT key, value pairs.",
        "rna_expression_adjustments": "DICT of length 10 with STR, INT key, value pairs.",
        "translation_efficiencies_adjustments": "DICT of length 24 with STR, INT key, value pairs."
    },
    "amino_acid_code_to_id_ordered": "DICT of length 21 with STR, STR key, value pairs.",
    "basal_expression_condition": "M9 Glucose minus AAs",
    "calculate_ppgpp_expression": "METHOD:  Calculates the expected expression of RNA based on ppGpp regulation in a given condition and the expected transcription factor effects in that condition. Relies on other values that are calculated in the fitting process so should only be called after the parca has been run. Args: condition: label for the desired condition to calculate the average expression for (eg. 'basal', 'with_aa', etc) ",
    "common_names": {
        "_build_common_names": "METHOD: None",
        "_build_synonyms": "METHOD: None",
        "_common_names": "DICT of length 26061 with STR, STR key, value pairs.",
        "_synonyms": "DICT of length 17958 with STR, LIST key, value pairs.",
        "get_common_name": "METHOD:  Returns the common name of the simulation element with the given ID. If a common name does not exist, returns the original element ID. Args: element_id (str): ID of the simulation element Returns: Common name of the given simulation element (str) ",
        "get_synonyms": "METHOD:  Returns a list of synonyms for the simulation element with the given ID. If a list of synonyms does not exist, returns a singleton list with the original element ID as the only entry. Args: element_id (str): ID of the simulation element Returns: List of synonyms for the given simulation element (str) "
    },
    "compartment_abbrev_to_id": "DICT of length 9 with STR, STR key, value pairs.",
    "compartment_abbrev_to_index": "DICT of length 9 with STR, INT key, value pairs.",
    "compartment_id_to_index": "DICT of length 9 with STR, INT key, value pairs.",
    "condition": "basal",
    "condition_active_tfs": "DICT of length 5 with STR, LIST key, value pairs.",
    "condition_inactive_tfs": "DICT of length 5 with STR, LIST key, value pairs.",
    "condition_to_doubling_time": "DICT of length 51 with STR, UNUM key, value pairs.",
    "conditions": "DICT of length 51 with STR, DICT key, value pairs.",
    "constants": {
        "KD_RelA_ribosome": "0.26 umol",
        "KI_SpoT_ppGpp_degradation": "20 umol",
        "Kdissociation_charged_trna_ribosome": "1 umol",
        "Kdissociation_uncharged_trna_ribosome": "500 umol",
        "Km_synthetase_amino_acid": "100 umol",
        "Km_synthetase_uncharged_trna": "1 umol",
        "RNAP_elongation_rate_for_stable_RNA": "85 nucleotide",
        "_build_constants": "METHOD: None",
        "c_period": "2400.026887280248 s",
        "cell_density": "1100 g",
        "complexation_rate": "1000 s",
        "d_period": "20 min",
        "darkATP": "33.58171361056091 mmol",
        "fraction_supply_exported": 0.1,
        "fraction_supply_inhibited": 0.01,
        "growth_associated_maintenance": "59.81 mmol",
        "gtp_per_translation": 4.2,
        "k_RelA_ppGpp_synthesis": "75 s",
        "k_SpoT_ppGpp_degradation": "0.23 L",
        "k_SpoT_ppGpp_synthesis": "2.6 s",
        "kcat_exoRNase": "50 s",
        "metabolism_homeostatic_range_obj_fraction_higher": 0,
        "metabolism_kinetic_objective_weight_in_range": 0.01,
        "metabolism_kinetic_objective_weight_linear": 1e-07,
        "metabolism_kinetic_objective_weight_quadratic": 1e-11,
        "n_avogadro": "6.02214076e+23 mol",
        "non_growth_associated_maintenance": "8.39 mmol",
        "pH": 7.2,
        "ppi_concentration": "0.0005 mol",
        "replisome_elongation_rate": "967 nucleotide",
        "ribosome_elongation_rate_basal": "22 amino_acid",
        "ribosome_elongation_rate_max": "30 amino_acid",
        "secretion_penalty_coeff": 0.001,
        "sensitivity_analysis_alpha": 0,
        "sensitivity_analysis_kcat_endo": 0,
        "stable_RNA_half_life": "2880 min",
        "synthetase_charging_rate": "100 s"
    },
    "dntp_code_to_id_ordered": "DICT of length 4 with STR, STR key, value pairs.",
    "doubling_time": "44.0 min",
    "expectedDryMassIncreaseDict": "DICT of length 9 with STR, UNUM key, value pairs.",
    "external_state": {
        "_get_all_external_exchange_molecules": "METHOD:  Returns: list[str]: all external exchange molecules ",
        "_get_secretion_exchange_molecules": "METHOD:  Returns: set[str]: all secretion exchange molecules ",
        "_initialize_environment": "METHOD: None",
        "all_external_exchange_molecules": "LIST of length 87 of STR types.",
        "carbon_sources": "LIST of length 3 of STR types.",
        "current_timeline_id": {},
        "env_to_exchange_map": "DICT of length 87 with STR, STR key, value pairs.",
        "exchange_data_from_concentrations": "METHOD:  Update importExchangeMolecules for FBA based on current nutrient concentrations. This provides a simple type of transport to accommodate changing nutrient concentrations in the environment. Transport is modeled as a binary switch: When there is a high concentrations of environment nutrients, transporters are unconstrained and nutrients are transported as needed by metabolism. When concentrations fall below the threshold, that nutrient's transport is constrained to max flux of 0. Args: molecules: external molecules (no location tag) with external concentration, concentration can be inf Returns dict with the following keys: externalExchangeMolecules (set[str]): all exchange molecules (with location tag), includes both import and secretion exchanged molecules importExchangeMolecules (set[str]): molecules (with location tag) that can be imported from the environment into the cell importConstrainedExchangeMolecules (dict[str, float with mol/mass/time units]): constrained molecules (with location tag) with upper bound flux constraints importUnconstrainedExchangeMolecules (set[str]): exchange molecules (with location tag) that do not have an upper bound on their flux secretionExchangeMolecules (set[str]): molecules (with location tag) that can be secreted by the cell into the environment ",
        "exchange_data_from_media": "METHOD:  Returns: dict: exchange_data for a media_label saved in exchange_data_dict. ",
        "exchange_dict": "DICT of length 20 with STR, DICT key, value pairs.",
        "exchange_to_env_map": "DICT of length 87 with STR, STR key, value pairs.",
        "get_import_constraints": "METHOD:  Returns: unconstrained_molecules (list[bool]): the indices of all importUnconstrainedExchangeMolecules in self.all_external_exchange_molecules are true, the rest as false constrained_molecules (list[bool]): the indices of all importConstrainedExchangeMolecules in self.all_external_exchange_molecules are true, the rest as false constraints (list[float]): uptake constraints for each molecule that is constrained, nan for no constraint ",
        "import_constraint_threshold": 1e-05,
        "make_media": {
            "_get_environment_molecules_fw": "METHOD: get formula weight (units.g / units.mol) for all environmental molecules",
            "_get_recipes": "METHOD: load recipes",
            "_get_stock_media": "METHOD: load all stock media",
            "add_ingredients": "METHOD:  Combines ingredients to existing media to make new media. Args: base_media (dict): {molecule_id: concentrations} base_media_volume: ingredients (dict): keys are ingredient ids, values are dicts with weight, counts, volume. Only one of weights (in g) or counts (in mmol) is needed; if both are specified, it will use weight. If weight or counts is Infinity, the new concentration is set to inf. If the weight or counts is -Infinity, the new concentration is set to 0. Example format of ingredients:  {mol_id_1: {'weight': 1.78 * units.g, 'volume': 0.025 * units.L),  mol_id_2: {'counts': 0.2 * units.mmol, 'volume': 0.1 * units.L),  } Returns: new_media (dict): {molecule_id: concentrations} ",
            "combine_media": "METHOD:  Combines two medias and returns a new media Args: base_media, mix_media (dict): dicts with {molecule_id: concentration} base_media_volume, mix_media_volume (unum): the volumes of base_media and mix_media (floats) with a volume units (i.e. units.L) Returns: new_media (dict): {molecule_id: concentrations} ",
            "environment_molecules_fw": "DICT of length 87 with STR, NONETYPE key, value pairs.",
            "make_recipe": "METHOD: make a single media recipe from self.recipes",
            "make_saved_media": "METHOD: make all the media recipes in self.recipes",
            "make_timeline": "METHOD:  Make a timeline from a string Args: timeline_str (str): 'time1 media_id1, time2 media_id2' Returns: timeline (list[tuple]): a list of tuples with (time (float), media_id (str)) TODO (Eran) make a parsing expression grammar for this: https://github.com/erikrose/parsimonious TODO (Eran) expand capabilities to also pass in ingredients to be added from the prior event ",
            "recipes": "DICT of length 20 with STR, DICT key, value pairs.",
            "saved_media": "DICT of length 20 with STR, DICT key, value pairs.",
            "stock_media": "DICT of length 5 with STR, DICT key, value pairs."
        },
        "saved_media": "DICT of length 20 with STR, DICT key, value pairs.",
        "saved_timelines": "DICT of length 29 with STR, LIST key, value pairs.",
        "secretion_exchange_molecules": "SET of length 36 of STR types."
    },
    "getter": {
        "_all_compartments": "DICT of length 16850 with STR, LIST key, value pairs.",
        "_all_genomic_coordinates": "DICT of length 6 with STR, TUPLE key, value pairs.",
        "_all_submass_arrays": "DICT of length 12804 with STR, NDARRAY key, value pairs.",
        "_all_total_masses": "DICT of length 12804 with STR, FLOAT64 key, value pairs.",
        "_build_all_masses": "METHOD:  Builds dictionary of molecular weights keyed with the IDs of molecules. Depending on the type of the molecule, weights are either pulled directly from raw data, or dynamically calculated from the existing data. ",
        "_build_compartments": "METHOD: None",
        "_build_full_chromosome_mass": "METHOD:  Calculates the mass of the full chromosome from its sequence and the weigths of polymerized dNTPs. ",
        "_build_genomic_coordinates": "METHOD:  Builds a dictionary of genomic coordinates of DNA sites. Keys are the IDs of the sites, and the values are tuples of the left-end coordinate and the right-end coordinate of the site. Sites whose types are included in IGNORED_DNA_SITE_TYPES are ignored. ",
        "_build_modified_protein_masses": "METHOD:  Builds dictionary of molecular weights of modified proteins keyed with the molecule IDs. Molecular weights are calculated from the stoichiometries of the modification reactions. ",
        "_build_modified_rna_masses": "METHOD:  Builds dictionary of molecular weights of modified RNAs keyed with the molecule IDs. Molecular weights are calculated from the stoichiometries of the modification reactions. ",
        "_build_polymerized_subunit_masses": "METHOD:  Builds dictionary of molecular weights of polymerized subunits (NTPs, dNTPs, and amino acids) by subtracting the end weights from the weights of original subunits. ",
        "_build_protein_complex_compartments": "METHOD:  Builds dictionary of compartment tags for protein complexes keyed with the molecule IDs. Each complex is assigned to the compartment that contains a subunit of the complex and has the highest complexation priority. Compartment tags of subunits that are also protein complexes are determined recursively. Compartments of metabolite subunits are not considered since metabolites are assigned to all compartments that are being modeled. ",
        "_build_protein_complex_masses": "METHOD:  Builds dictionary of molecular weights of protein complexes keyed with the molecule IDs. Molecular weights are calculated from the stoichiometries of the complexation/equilibrium reactions. For complexes whose subunits are also complexes, the molecular weights are calculated recursively. ",
        "_build_protein_masses": "METHOD:  Builds dictionary of molecular weights of protein monomers keyed with the protein IDs. Molecular weights are calculated from the protein sequence and the weights of polymerized amino acids. ",
        "_build_protein_sequences": "METHOD:  Builds the amino acid sequences of each protein monomer using sequences in raw_data. ",
        "_build_rna_masses": "METHOD:  Builds dictionary of molecular weights of RNAs keyed with the RNA IDs. Molecular weights are calculated from the RNA sequence and the weights of polymerized NTPs. ",
        "_build_rna_sequences": "METHOD:  Builds nucleotide sequences of each transcription unit using the genome sequence and the left and right end positions. ",
        "_build_sequences": "METHOD:  Builds sequences of RNAs and proteins. ",
        "_build_submass_array": "METHOD:  Converts a scalar molecular weight value to an array of submasses, given the name of the submass category that the molecule belongs to. ",
        "_compartment_tag": {
            "findall": "METHOD: Return a list of all non-overlapping matches of pattern in string.",
            "finditer": "METHOD: None",
            "flags": 32,
            "fullmatch": "METHOD: None",
            "groupindex": "EMPTY DICT",
            "groups": 0,
            "match": "METHOD: None",
            "pattern": "\\[[a-z]]",
            "scanner": "METHOD: None",
            "search": "METHOD: None",
            "split": "METHOD: Split string by the occurrences of pattern.",
            "sub": "METHOD: None",
            "subn": "METHOD: None"
        },
        "_mass_units": "1.0 g",
        "_miscrna_id_to_singleton_tu_id": "DICT of length 57 with STR, STR key, value pairs.",
        "_n_submass_indexes": 9,
        "_sequences": "DICT of length 7865 with STR, SEQ key, value pairs.",
        "_submass_name_to_index": "DICT of length 9 with STR, INT key, value pairs.",
        "get_all_valid_molecules": "METHOD:  Returns a list of all molecule IDs with assigned submass arrays and compartments. ",
        "get_compartment": "METHOD:  Returns the list of one-letter codes for the compartments that the molecule with the given ID can exist in. ",
        "get_compartment_tag": "METHOD:  Look up a molecule id and return a compartment suffix tag like '[c]'. ",
        "get_compartments": "METHOD:  Returns a list of the list of one-letter codes for the compartments that each of the molecules with the given IDs can exist in. ",
        "get_genomic_coordinates": "METHOD:  Returns the genomic coordinates of the left and right ends of a DNA site given the ID of the site. ",
        "get_mass": "METHOD:  Return the total mass of the molecule with a given ID. ",
        "get_masses": "METHOD:  Return an array of total masses of the molecules with the given IDs. ",
        "get_miscrnas_with_singleton_tus": "METHOD:  Returns a list of all miscRNA IDs with corresponding single-gene transcription units. ",
        "get_sequences": "METHOD:  Return a list of sequences of the molecules with the given IDs. ",
        "get_singleton_tu_id": "METHOD:  Returns the ID of the single-gene transcription unit corresponding to the given miscRNA ID, if such a transcription unit exists. This is necessary to replace some references to miscRNA IDs in complexation or equilibrium reactions with their corresponding TU IDs, which are the molecules that are actually transcribed. ",
        "get_submass_array": "METHOD:  Return the submass array of the molecule with a given ID. ",
        "is_valid_molecule": "METHOD:  Returns True if the molecule with the given ID is a valid molecule (has both a submass array and a compartment tag). "
    },
    "growth_rate_parameters": {
        "RNAP_active_fraction_params": "DICT of length 4 with STR, CUBICSPLINE key, value pairs.",
        "RNAP_elongation_rate_params": "DICT of length 4 with STR, CUBICSPLINE key, value pairs.",
        "RNAP_per_cell": 4331.100389105059,
        "_charging_fraction_of_max_elong_rate": 0.9,
        "_doubling_time": "44.0 min",
        "_fit_ribosome_elongation_rate_by_ppgpp": "METHOD: None",
        "_ppGpp_concentration": "TUPLE of length 3 of UNUM types.",
        "_ribosome_elongation_rate_by_ppgpp": "TUPLE of length 5 of UNUM types.",
        "distanceBetweenRibosomesOnMRna": "69.62443579766537 nucleotide",
        "fractionActiveRibosome": 0.8,
        "fractionActiveRnap": 0.20748264591439688,
        "fractionActiveRnapSynthesizingStableRna": 0.517711439688716,
        "get_fraction_active_ribosome": "METHOD: None",
        "get_fraction_active_rnap": "METHOD: None",
        "get_ppGpp_conc": "METHOD: None",
        "get_ribosome_elongation_rate": "METHOD: None",
        "get_ribosome_elongation_rate_by_ppgpp": "METHOD: None",
        "get_rnap_elongation_rate": "METHOD: None",
        "per_dry_mass_to_per_volume": "330.00000000000006 g",
        "ppGpp_conc": "0.14457346614785993 pmol",
        "ratioRProteinToTotalProtein": 0.14090639688715953,
        "ribosomeElongationRate": "17.388824902723737 amino_acid",
        "ribosome_active_fraction_params": "DICT of length 4 with STR, CUBICSPLINE key, value pairs.",
        "ribosome_elongation_rate_params": "DICT of length 4 with STR, CUBICSPLINE key, value pairs.",
        "rnaPolymeraseElongationRate": "49.24280155642024 nucleotide",
        "stableRnaPerTotalRnaSynthesized": 0.6434845136186771
    },
    "initialize": "METHOD: None",
    "internal_state": {
        "_build_bulk_molecule_specs": "METHOD:  Builds a list of molecule IDs with compartment tags and a corresponding array of molecular masses to add to the bulk state. Args: molecule_ids (List[str]): List of molecule IDs w/o compartment tags Returns: molecule_ids_with_compartments (List[str]): List of molecule IDs with compartment tags masses (np.ndarray): Array of molecular masses divided into submasses ",
        "_build_bulk_molecules": "METHOD:  Add data (IDs and mass) for all classes of bulk molecules. ",
        "_build_compartments": "METHOD: None",
        "_build_unique_molecules": "METHOD:  Add data (name, mass, and attribute data structure) for all classes of unique molecules. ",
        "bulk_molecules": {
            "add_to_bulk_state": "METHOD: None",
            "bulk_data": {
                "_field": "METHOD: None",
                "_validate": "METHOD: None",
                "fullArray": "METHOD: None",
                "fullUnits": "METHOD: None",
                "struct_array": "ndarray of length 16307 and shape (16307,)",
                "units": "DICT of length 2 with STR, NONETYPE key, value pairs."
            }
        },
        "compartments": "ndarray of length 9 and shape (9,)",
        "unique_molecule": {
            "add_to_unique_state": "METHOD: None",
            "unique_molecule_definitions": "DICT of length 11 with STR, DICT key, value pairs.",
            "unique_molecule_masses": {
                "_field": "METHOD: None",
                "_validate": "METHOD: None",
                "fullArray": "METHOD: None",
                "fullUnits": "METHOD: None",
                "struct_array": "ndarray of length 11 and shape (11,)",
                "units": "DICT of length 2 with STR, NONETYPE key, value pairs."
            }
        }
    },
    "mass": {
        "_LPSFractions": "LIST of length 1 of DICT types.",
        "_build_CD_periods": "METHOD: None",
        "_build_constants": "METHOD: None",
        "_build_dependent_constants": "METHOD: None",
        "_build_submasses": "METHOD: None",
        "_build_trna_data": "METHOD: None",
        "_c_period": "2400.026887280248 s",
        "_calculateGrowthRateDependentDnaMass": "METHOD: None",
        "_cellDensity": "1100 g",
        "_clipTau_d": "METHOD: None",
        "_d_period": "20 min",
        "_doubling_time": "44.0 min",
        "_doubling_time_vector": "[100.  60.  40.  30.  24.] min",
        "_dryMassParams": "TUPLE of length 2 of FLOAT64 types.",
        "_getFitParameters": "METHOD: None",
        "_glycogenFractions": "LIST of length 1 of DICT types.",
        "_glycogenMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_inorganicIonMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_ionFractions": "LIST of length 9 of DICT types.",
        "_lipidFractions": "LIST of length 3 of DICT types.",
        "_lipidMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_lpsMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_metTargetIds": "LIST of length 125 of STR types.",
        "_mrna_mass_sub_fraction": 0.041,
        "_mureinFractions": "LIST of length 1 of DICT types.",
        "_mureinMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_mws": "DICT of length 41 with STR, UNUM key, value pairs.",
        "_proteinMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_rnaMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_rrna16s_mass_sub_fraction": 0.271,
        "_rrna23s_mass_sub_fraction": 0.525,
        "_rrna5s_mass_sub_fraction": 0.017,
        "_solubleFractions": "LIST of length 25 of DICT types.",
        "_solublePoolMassFractionParams": "TUPLE of length 2 of TUPLE types.",
        "_trna_growth_rates": "[0.4  0.7  1.07 1.6  2.5 ] h",
        "_trna_ids": "LIST of length 86 of STR types.",
        "_trna_mass_sub_fraction": 0.146,
        "_trna_ratio_to_16SrRNA_by_growth_rate": "ndarray of length 5 and shape (5, 86)",
        "avg_cell_cell_cycle_progress": 0.44,
        "avg_cell_component_masses": "DICT of length 9 with STR, UNUM key, value pairs.",
        "avg_cell_dry_mass": "452.868707675953 fg",
        "avg_cell_dry_mass_init": "333.82519760052986 fg",
        "avg_cell_to_initial_cell_conversion_factor": 1.3566043274476718,
        "avg_cell_water_mass_init": "778.9254610679028 fg",
        "cell_dry_mass_fraction": 0.30000000000000004,
        "cell_water_mass_fraction": 0.7,
        "chromosome_sequence_mass": "4.7470674204101474e-15 g",
        "fitAvgSolubleTargetMolMass": "169.5538216696535 fg",
        "getBiomassAsConcentrations": "METHOD: None",
        "get_avg_cell_dry_mass": "METHOD:  Gets the dry mass for an average cell at the given doubling time. Args: doubling_time: expected doubling time Returns: average cell dry mass ",
        "get_basal_rna_fractions": "METHOD:  Measured RNA subgroup mass fractions. Fractions should change in other conditions with growth rate (see transcription.get_rna_fractions()). ",
        "get_component_masses": "METHOD: None",
        "get_dna_critical_mass": "METHOD:  Returns the critical mass for replication initiation. Faster growing cells maintain a consistent initiation mass but slower growing cells are smaller and will never reach this mass so it needs to be adjusted lower for them. Args: doubling_time: expected doubling time of cell Returns: Critical mass for DNA replication initiation ",
        "get_mass_fractions": "METHOD: None",
        "get_mass_fractions_from_rna_protein_ratio": "METHOD: None",
        "get_trna_distribution": "METHOD: None",
        "mass_fractions": "DICT of length 9 with STR, FLOAT64 key, value pairs."
    },
    "molecule_groups": {
        "RNAP_subunits": "LIST of length 3 of STR types.",
        "_build_molecule_groups": "METHOD: None",
        "amino_acids": "LIST of length 21 of STR types.",
        "bulk_molecules_binomial_division": "LIST of length 16307 of STR types.",
        "bulk_molecules_equal_division": "EMPTY LIST",
        "carbon_sources": "LIST of length 3 of STR types.",
        "dntps": "LIST of length 4 of STR types.",
        "endoRNase_rnas": "LIST of length 9 of STR types.",
        "exoRNase_rnas": "LIST of length 9 of STR types.",
        "exoRNases": "LIST of length 9 of STR types.",
        "lipids": "LIST of length 3 of STR types.",
        "nmps": "LIST of length 4 of STR types.",
        "ntps": "LIST of length 4 of STR types.",
        "polyamines": "LIST of length 6 of STR types.",
        "polymerized_amino_acids": "LIST of length 21 of STR types.",
        "polymerized_dntps": "LIST of length 4 of STR types.",
        "polymerized_ntps": "LIST of length 4 of STR types.",
        "polymerized_subunits": "LIST of length 29 of STR types.",
        "rRNA_operons": "LIST of length 7 of STR types.",
        "replisome_monomer_subunits": "LIST of length 4 of STR types.",
        "replisome_trimer_subunits": "LIST of length 2 of STR types.",
        "ribosomal_proteins": "LIST of length 54 of STR types.",
        "rrnA": "LIST of length 5 of STR types.",
        "rrnA_rRNA": "LIST of length 3 of STR types.",
        "rrnB": "LIST of length 4 of STR types.",
        "rrnB_rRNA": "LIST of length 3 of STR types.",
        "rrnC": "LIST of length 4 of STR types.",
        "rrnC_rRNA": "LIST of length 3 of STR types.",
        "rrnD": "LIST of length 7 of STR types.",
        "rrnD_rRNA": "LIST of length 4 of STR types.",
        "rrnE": "LIST of length 4 of STR types.",
        "rrnE_rRNA": "LIST of length 3 of STR types.",
        "rrnG": "LIST of length 4 of STR types.",
        "rrnG_rRNA": "LIST of length 3 of STR types.",
        "rrnH": "LIST of length 5 of STR types.",
        "rrnH_rRNA": "LIST of length 3 of STR types.",
        "rrn_operons": "LIST of length 7 of STR types.",
        "s30_16s_rRNA": "LIST of length 7 of STR types.",
        "s30_proteins": "LIST of length 21 of STR types.",
        "s50_23s_rRNA": "LIST of length 7 of STR types.",
        "s50_5s_rRNA": "LIST of length 8 of STR types.",
        "s50_protein_complexes": "LIST of length 1 of STR types.",
        "s50_proteins": "LIST of length 33 of STR types.",
        "twoComponentSystems": "LIST of length 7 of DICT types.",
        "unique_molecules_RNA_division": "LIST of length 1 of STR types.",
        "unique_molecules_active_ribosome_division": "LIST of length 1 of STR types.",
        "unique_molecules_chromosomal_segment_division": "LIST of length 1 of STR types.",
        "unique_molecules_domain_index_division": "LIST of length 8 of STR types."
    },
    "molecule_ids": {
        "DnaA": "PD03831[c]",
        "DnaA_ATP_complex": "MONOMER0-160[c]",
        "LPS": "CPD0-939[c]",
        "RelA": "RELA-MONOMER[c]",
        "SpoT": "SPOT-MONOMER[c]",
        "_buildMoleculeIds": "METHOD: None",
        "full_RNAP": "APORNAP-CPLX[c]",
        "full_chromosome": "CHROM_FULL[c]",
        "glycogen": "glycogen-monomer[c]",
        "murein": "CPD-12261[p]",
        "oriC_site": "G0-10506",
        "ppGpp": "GUANOSINE-5DP-3DP[c]",
        "ppi": "PPI[c]",
        "proton": "PROTON[c]",
        "s30_full_complex": "CPLX0-3953[c]",
        "s50_full_complex": "CPLX0-3962[c]",
        "terC_site": "TERC",
        "water": "WATER[c]"
    },
    "nmp_code_to_id_ordered": "DICT of length 4 with STR, STR key, value pairs.",
    "ntp_code_to_id_ordered": "DICT of length 4 with STR, STR key, value pairs.",
    "nutrient_to_doubling_time": "DICT of length 5 with STR, UNUM key, value pairs.",
    "operons_on": true,
    "ordered_conditions": "LIST of length 5 of STR types.",
    "pPromoterBound": "DICT of length 51 with STR, DICT key, value pairs.",
    "process": {
        "chromosome_structure": {
            "_build_supercoiling_parameters": "METHOD:  Load parameters used for DNA supercoiling from raw_data. ",
            "relaxed_DNA_base_pairs_per_turn": 10.5,
            "terC_dummy_molecule_index": -1
        },
        "complexation": {
            "_buildStoichMatrixMonomers": "METHOD:  Builds a stoichiometric matrix where each column is a reaction that forms a complex directly from its constituent monomers. Since some reactions from the raw data are complexation reactions of complexes, this is different from the stoichiometric matrix generated by stoichMatrix(). ",
            "_findColumn": "METHOD: None",
            "_findRow": "METHOD: None",
            "_moleculeRecursiveSearch": "METHOD: None",
            "_stoichMatrixMonomersI": "ndarray of length 2908 and shape (2908,)",
            "_stoichMatrixMonomersJ": "ndarray of length 2908 and shape (2908,)",
            "_stoichMatrixMonomersShape": "TUPLE of length 2 of INT64 types.",
            "_stoichMatrixMonomersV": "ndarray of length 2908 and shape (2908,)",
            "_stoich_matrix_I": "ndarray of length 2826 and shape (2826,)",
            "_stoich_matrix_J": "ndarray of length 2826 and shape (2826,)",
            "_stoich_matrix_V": "ndarray of length 2826 and shape (2826,)",
            "_stoich_matrix_mass": "ndarray of length 2826 and shape (2826,)",
            "complex_names": "SET of length 1118 of STR types.",
            "get_monomers": "METHOD:  Returns subunits for a complex (or any ID passed). If the ID passed is already a monomer returns the monomer ID again with a stoichiometric coefficient of one. ",
            "ids_complexes": "LIST of length 1118 of STR types.",
            "ids_reactions": "LIST of length 1118 of STR types.",
            "mass_matrix": "METHOD:  Builds a matrix with the same shape as the stoichiometric matrix, but with molecular masses as elements instead of stoichiometric constants ",
            "molecule_names": "LIST of length 2678 of STR types.",
            "prebuilt_matrices": "TUPLE of length 2 of NDARRAY types.",
            "rates": "ndarray of length 1118 and shape (1118,)",
            "reaction_stoichiometry_unknown": "ndarray of length 1118 and shape (1118,)",
            "stoich_matrix": "METHOD:  Builds a stoichiometric matrix based on each given complexation reaction. One reaction corresponds to one column in the stoichiometric matrix. ",
            "stoich_matrix_monomers": "METHOD:  Returns the dense stoichiometric matrix for monomers from each complex ",
            "subunit_names": "SET of length 1638 of STR types."
        },
        "equilibrium": {
            "Pp": "ndarray of length 108 and shape (108, 39)",
            "Rp": "ndarray of length 108 and shape (108, 39)",
            "_findColumn": "METHOD: None",
            "_findRow": "METHOD: None",
            "_makeMatrices": "METHOD:  Creates matrix that maps metabolites to the flux through their reactions. ",
            "_make_rates": "METHOD:  Creates symbolic representation of the rates for ordinary differential equations and the Jacobian. Used during simulations. ",
            "_moleculeRecursiveSearch": "METHOD: None",
            "_populateDerivativeAndJacobian": "METHOD: Compile callable functions for computing the derivative and the Jacobian.",
            "_rates": "TUPLE of length 2 of FUNCTION types.",
            "_rates_jacobian": "TUPLE of length 2 of FUNCTION types.",
            "_stoichMatrix": "ndarray of length 108 and shape (108, 39)",
            "_stoichMatrixI": "ndarray of length 117 and shape (117,)",
            "_stoichMatrixJ": "ndarray of length 117 and shape (117,)",
            "_stoichMatrixMass": "ndarray of length 117 and shape (117,)",
            "_stoichMatrixV": "ndarray of length 117 and shape (117,)",
            "balance_matrix": "ndarray of length 108 and shape (108, 39)",
            "complex_name_to_rxn_idx": "DICT of length 39 with STR, INT key, value pairs.",
            "derivatives": "METHOD: None",
            "derivatives_jacobian": "METHOD: None",
            "derivatives_jacobian_jit": "METHOD: None",
            "derivatives_jit": "METHOD: None",
            "fluxes_and_molecules_to_SS": "METHOD: None",
            "get_fwd_rate": "METHOD: None",
            "get_metabolite": "METHOD: None",
            "get_metabolite_coeff": "METHOD: None",
            "get_monomers": "METHOD:  Returns subunits for a complex (or any ID passed). If the ID passed is already a monomer returns the monomer ID again with a stoichiometric coefficient of one. ",
            "get_rev_rate": "METHOD: None",
            "get_unbound": "METHOD: None",
            "ids_complexes": "LIST of length 39 of STR types.",
            "mass_balance": "METHOD:  Sum along the columns of the massBalance matrix to check for reaction mass balance ",
            "mass_matrix": "METHOD:  Builds stoichiometry mass matrix Rows: molecules Columns: reactions Values: molecular mass ",
            "metabolite_set": "SET of length 35 of STR types.",
            "mets_to_rxn_fluxes": "ndarray of length 39 and shape (39, 108)",
            "molecule_names": "LIST of length 108 of STR types.",
            "rates_fwd": "ndarray of length 39 and shape (39,)",
            "rates_rev": "ndarray of length 39 and shape (39,)",
            "rxn_ids": "LIST of length 39 of STR types.",
            "set_fwd_rate": "METHOD: None",
            "set_rev_rate": "METHOD: None",
            "stoich_matrix": "METHOD:  Builds stoichiometry matrix Rows: molecules Columns: reactions Values: reaction stoichiometry ",
            "stoich_matrix_monomers": "METHOD:  Builds a stoichiometric matrix where each column is a reaction that forms a complex directly from its constituent monomers. Since some reactions from the raw data are complexation reactions of complexes, this is different from the stoichiometric matrix generated by stoichMatrix(). ",
            "symbolic_rates": "MutableDenseMatrix of length 39 and shape (39, 1)",
            "symbolic_rates_jacobian": "MutableDenseMatrix of length 4212 and shape (39, 108)"
        },
        "metabolism": {
            "KI_aa_synthesis": "ndarray of length 21 and shape (21,)",
            "KM_aa_export": "ndarray of length 21 and shape (21,)",
            "_add_metabolite_charge": "METHOD:  Compiles all metabolite charges. Args: raw_data: Raw data object Attributes set: - :py:attr:`~.metabolite_charge` ",
            "_build_amino_acid_pathways": "METHOD:  Creates mapping between enzymes and amino acid pathways with allosteric inhibition feedback from the amino acid. Args: raw_data: Raw data object sim_data: Simulation data object Attributes set: - :py:attr:`~.aa_synthesis_pathways` ",
            "_build_biomass": "METHOD:  Calculates metabolite concentration targets. Args: raw_data: Raw data object sim_data: Simulation data object Attributes set: - :py:attr:`~.concentration_updates` - :py:attr:`~.conc_dict` - :py:attr:`~.nutrients_to_internal_conc` ",
            "_build_linked_metabolites": "METHOD:  Calculates ratio between linked metabolites to keep it constant throughout a simulation. Args: raw_data: Raw data object conc_dict: Mapping of metabolite IDs to homeostatic concentrations calculated by :py:meth:`~_build_biomass` Returns: Mapping from a linked metabolite to its lead metabolite and concentration ratio to be maintained::  {'lead' (str): metabolite to link the concentration to,  'ratio' (float): ratio to multiply the lead concentration by} ",
            "_build_metabolism": "METHOD:  Build the matrices/vectors for metabolism (FBA) Reads in and stores reaction and kinetic constraint information Args: raw_data: Raw data object sim_data: Simulation data object Attributes set: - :py:attr:`~.kinetic_constraint_reactions` - :py:attr:`~.kinetic_constraint_enzymes` - :py:attr:`~.kinetic_constraint_substrates` - :py:attr:`~._kcats` - :py:attr:`~._saturations` - :py:attr:`~._enzymes` - :py:attr:`~.constraint_is_kcat_only` - :py:attr:`~._compiled_enzymes` - :py:attr:`~._compiled_saturation` - :py:attr:`~.reaction_stoich` - :py:attr:`~.maintenance_reaction` - :py:attr:`~.reaction_catalysts` - :py:attr:`~.catalyst_ids` - :py:attr:`~.reactions_with_catalyst` - :py:attr:`~.catalysis_matrix_I` - :py:attr:`~.catalysis_matrix_J` - :py:attr:`~.catalysis_matrix_V` - :py:attr:`~.use_all_constraints` - :py:attr:`~.constraints_to_disable` - :py:attr:`~.base_reaction_ids` - :py:attr:`~.reaction_id_to_base_reaction_id` - :py:attr:`~.amino_acid_export_kms` ",
            "_build_ppgpp_reactions": "METHOD:  Creates structures for ppGpp reactions for use in polypeptide_elongation. Args: raw_data: Raw data object sim_data: Simulation data object Attributes set: - :py:attr:`~.ppgpp_synthesis_reaction` - :py:attr:`~.ppgpp_degradation_reaction` - :py:attr:`~.ppgpp_reaction_names` - :py:attr:`~.ppgpp_reaction_metabolites` - :py:attr:`~.ppgpp_reaction_stoich` ",
            "_build_transport_reactions": "METHOD:  Creates list of transport reactions that are included in the reaction network. Args: raw_data: Raw data object sim_data: Simulation data object Attributes set: - :py:attr:`~.transport_reactions` ",
            "_compiled_enzymes": {},
            "_compiled_saturation": {},
            "_construct_default_saturation_equation": "METHOD:  Args: mets: metabolite IDs with location tag for KM and KI parameters ordered to match order of kms then kis kms: KM parameters associated with mets kis: KI parameters associated with mets known_mets: metabolite IDs with location tag with known concentrations Returns: Saturation equation with metabolites to replace delimited by double quote (e.g. \"metabolite\") ",
            "_enzymes": "[e[250], e[199], e[125], e[33], e[33], e[33], e[33], e[33], e[33], e[261], e[17], e[70], e[48], e[29], e[39], e[18], e[0], e[199], e[197], e[148], e[155], e[191], e[137], e[154], e[135], e[134], e[12], e[41], e[160], e[1], e[2], e[3], e[257], e[5], e[6], e[6], e[7], e[43], e[42], e[122], e[8], e[9], e[10], e[109], e[109], e[101], e[101], e[55], e[141], e[16], e[15], e[22], e[22], e[23], e[23], e[297], e[14], e[24], e[26], e[25], e[27], e[27], e[28], e[31], e[31], e[31], e[32], e[43], e[236], e[34], e[35], e[36], e[37], e[112], e[113], e[91], e[19], e[20], e[21], e[116], e[117], e[118], e[40], e[40], e[57], e[57], e[119], e[120], e[123], e[124], e[176], e[174], e[98], e[98], e[126], e[127], e[127], e[87], e[87], e[129], e[130], e[200], e[131], e[69], e[177], e[110], e[184], e[183], e[53], e[86], e[148], e[178], e[180], e[182], e[151], e[75], e[185], e[185], e[186], e[186], e[195], e[212], e[212], e[213], e[214], e[216], e[217], e[218], e[161], e[161], e[161], e[220], e[220], e[220], e[155], e[305], e[221], e[22], e[32], e[77], e[78], e[113], e[222], e[223], e[215], e[224], e[224], e[225], e[11], e[227], e[62], e[193], e[228], e[228], e[229], e[229], e[230], e[194], e[58], e[231], e[237], e[233], e[234], e[235], e[274], e[238], e[122], e[51], e[175], e[175], e[254], e[239], e[72], e[240], e[241], e[269], e[243], e[244], e[79], e[246], e[247], e[248], e[249], e[251], e[252], e[253], e[253], e[262], e[255], e[150], e[83], e[42], e[92], e[256], e[258], e[259], e[64], e[260], e[261], e[111], e[262], e[232], e[268], e[263], e[185], e[89], e[264], e[265], e[266], e[269], e[269], e[271], e[90], e[90], e[272], e[272], e[267], e[268], e[267], e[273], e[274], e[34], e[35], e[275], e[277], e[277], e[277], e[268], e[268], e[232], e[187], e[187], e[136], e[282], e[282], e[283], e[61], e[173], e[168], e[209], e[285], e[58], e[4], e[281], e[165], e[67], e[81], e[149], e[38], e[163], e[145], e[204], e[171], e[156], e[66], e[66], e[92], e[56], e[60], e[132], e[16], e[16], e[226], e[160], e[16], e[160], e[16], e[226], e[105], e[160], e[16], e[74], e[226], e[74], e[16], e[16], e[16], e[16], e[16], e[73], e[245], e[115], e[296], e[128], e[242], e[13], e[44], e[162], e[269], e[269], e[188], e[106], e[207], e[207], e[16], e[207], e[38], e[236], e[68], e[302], e[169], e[107], e[179], e[243], e[166], e[220], e[142], e[88], e[44], e[206], e[46], e[47], e[65], e[52], e[45], e[181], e[74], e[202], e[231], e[76], e[158], e[94], e[82], e[59], e[105], e[200], e[63], e[276], e[284], e[146], e[152], e[201], e[157], e[203], e[147], e[192], e[198], e[196], e[211], e[227], e[74], e[210], e[190], e[143], e[80], e[54], e[133], e[164], e[208], e[205], e[138], e[219], e[172], e[234], e[87], e[87], e[91], e[93], e[139], e[280], e[95], e[170], e[97], e[248], e[85], e[84], e[167], e[103], e[153], e[201], e[71], e[242], e[242], e[59], e[85], e[30], e[279], e[278], e[96], e[286], e[62], e[189], e[49], e[114], e[287], e[288], e[108], e[289], e[199], e[50], e[140], e[290], e[246], e[291], e[121], e[293], e[294], e[295], e[292], e[51], e[159], e[144], e[297], e[100], e[298], e[99], e[299], e[299], e[102], e[300], e[301], e[104], e[270], e[121], e[303], e[304]]",
            "_extract_custom_constraint": "METHOD:  Args: constraint: values defining a kinetic constraint:: {'customRateEquation' (str): mathematical representation of  rate (must contain 'kcat*E'), 'customParameterVariables' (dict[str, str]): mapping of  variable names in the rate equation to metabolite IDs  without location tags (must contain 'E'), 'customParameterConstants' (list[str]): constant strings  in the rate equation that correspond to values (must  contain 'kcat'), 'customParameterConstantValues' (list[float]): values for  each of the constant strings, 'Temp' (float or ''): temperature of measurement} reactant_tags: mapping of molecule IDs without a location tag to molecule IDs with a location tag for all reactants product_tags: mapping of molecule IDs without a location tag to molecule IDs with a location tag for all products known_mets: molecule IDs with a location tag for molecules with known concentrations Returns: 2-element tuple containing - kcats: temperature adjusted kcat value, in units of 1/s - saturation: saturation equation with metabolites to replace  delimited by double quote (eg. \"metabolite\") ",
            "_is_transport_rxn": "METHOD:  Determines if the metabolic reaction with a given stoichiometry is a transport reactions that transports metabolites between different compartments. A metabolic reaction is considered to be a transport reaction if the substrate set and the product share the same metabolite tagged into different compartments. Args: stoich: Stoichiometry of the metabolic reaction:: { metabolite ID (str): stoichiometric coefficient (int) } Returns: True if given stoichiometry is a transport reaction ",
            "_kcats": "ndarray of length 416 and shape (416, 3)",
            "_lambdify_constraints": "METHOD:  Creates str representations of kinetic terms to be used to create kinetic constraints that are returned with getKineticConstraints(). Args: constraints: valid kinetic constraints for each reaction:: {reaction ID: {  'enzyme': enzyme catalyst (str),  'kcat': kcat values (list[float]),  'saturation': saturation equations (list[str]) }} Returns: 7-element tuple containing - rxns: sorted reaction IDs for reactions with a kinetic  constraint - enzymes: sorted enzyme IDs for enzymes that catalyze a  kinetic reaction - substrates: sorted substrate IDs for substrates that are  needed for kinetic saturation terms - all_kcats: (n rxns, 3) min, mean and max kcat value for  each reaction - all_saturations: sympy str representation of a list of  saturation terms (eg. '[s[0] / (1 + s[0]), 2 / (2 + s[1])]') - all_enzymes: sympy str representation of enzymes for each  reaction (e.g. '[e[0], e[2], e[1]]') - constraint_is_kcat_only: True if reaction only has kcat  values and no saturation terms ",
            "_replace_enzyme_reactions": "METHOD:  Modifies reaction IDs in data structures to duplicate reactions with kinetic constraints and multiple enzymes. Args: constraints: valid kinetic constraints for each reaction/enzyme pair:: {(reaction ID, enzyme with location tag): {  'kcat': kcat values (list[float]),  'saturation': saturation equations (list[str]) }} stoich: stoichiometry of metabolites for each reaction (if None, data is loaded from raw_data and sim_data):: {reaction ID: {metabolite ID with location tag: stoichiometry}} rxn_catalysts: enzyme catalysts for each reaction with known catalysts, likely a subset of reactions in stoich (if None, data is loaded from raw_data and sim_data):: {reaction ID: enzyme IDs with location tag} reversible_rxns: reaction IDs for reactions that have a reverse complement, does not have reverse tag rxn_id_to_compiled_id: mapping from reaction IDs to the IDs of the original reactions they were derived from Returns: 5-element tuple containing - new_constraints: valid kinetic constraints for each reaction::  {reaction ID: {  'enzyme': enzyme catalyst (str),  'kcat': kcat values (list[float]),  'saturation': saturation equations (list[str])  }} - stoich: stoichiometry of metabolites for each reaction with  updated reactions for enzyme catalyzed kinetic reactions::  {reaction ID: {metabolite ID with location tag: stoichiometry}} - rxn_catalysts: enzyme catalysts for each reaction with known  catalysts, likely a subset of reactions in stoich with  updated reactions for enzyme catalyzed kinetic reactions::  {reaction ID: enzyme IDs with location tag} - reversible_rxns: reaction IDs for reactions that have a reverse  complement with updated reactions for enzyme catalyzed kinetic  reactions, does not have reverse tag - rxn_id_to_compiled_id: mapping from reaction IDs to the IDs  of the original reactions they were derived from, with updated  reactions for enzyme catalyzed kinetic reactions ",
            "_saturations": "[[1/((1 + 660.0/s[55])*(1 + 68.8/s[62]))], [1/(1 + 94.0/s[62])], [0, 1], [1/(1 + 89.4/s[73]), 1/(1 + 90.0/s[73]), 1/(1 + 70.0/s[73])], [1/(1 + 89.4/s[73]), 1/(1 + 90.0/s[73]), 1/(1 + 70.0/s[73])], [1/(1 + 89.4/s[73]), 1/(1 + 90.0/s[73]), 1/(1 + 70.0/s[73])], [1/(1 + 89.4/s[73]), 1/(1 + 90.0/s[73]), 1/(1 + 70.0/s[73])], [1/(1 + 89.4/s[73]), 1/(1 + 90.0/s[73]), 1/(1 + 70.0/s[73])], [1/(1 + 89.4/s[73]), 1/(1 + 90.0/s[73]), 1/(1 + 70.0/s[73])], [0, 1], [1/(1 + 100.0/s[64]), 1/(1 + 160.0/s[64])], [1/(1 + 1.5/s[1]), 1/(1 + 9.9/s[1])], [1/(1 + 3.0/s[17]), s[17]/(s[17]**2/19600 + s[17] + 760)], [0, 1], [0, 1], [0, 1], [1/(1 + 321.0/s[62])], [1/(1 + 70.0/s[62])], [0, 1], [1/(1 + 370.0/s[68])], [1/(1 + 1500.0/s[68])], [1/(1 + 680.0/s[68])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [s[32]**2.11*s[9]/((s[32]**2.11 + 13287.7575374544)*(s[9] + 110))], [1/((1 + 18.0/s[32])*(1 + 12.0/s[9]))], [1/(1 + 279.0/s[62])], [0, 1], [1/(1 + 4800.0/s[69])], [1/(1 + 5200.0/s[69]), 1/(1 + 5000.0/s[69]), 1/(1 + 6600.0/s[69]), 1/(1 + 6600.0/s[69])], [1/(1 + 2600.0/s[69])], [1/(1 + 1200.0/s[58]), 1/(1 + 1200.0/s[58]), 1/(1 + 1200.0/s[58])], [1/(1 + 400.0/s[6]), 1/(1 + 400.0/s[6])], [0, 1], [1/(1 + 46.0/s[7])], [0, 1], [1/((1 + 26.0/s[43])*(1 + 28.0/s[47])*(1 + 230.0/s[50])), 1/((1 + 26.0/s[43])*(1 + 28.0/s[47])*(1 + 230.0/s[50])), 1/((1 + 26.0/s[43])*(1 + 28.0/s[47])*(1 + 230.0/s[50]))], [0, 1], [1/(1 + 290.0/s[49]), 1/(1 + 1008.0/s[49])], [0, 1], [0, 1], [0, 1], [1/(1 + 54.0/s[62])], [0, 1], [0, 1], [1/(1 + 2500.0/s[36])], [1/(1 + 530.0/s[50]), 1/(1 + 110.0/s[9]), 1/(1 + 1200.0/s[50])], [1/(1 + 660.0/s[36]), 1/(1 + 850.0/s[50]), 1/(1 + 260.0/s[9]), 1/(1 + 690.0/s[36]), 1/(1 + 690.0/s[36]), 1/(1 + 680.0/s[50]), 1/(1 + 180.0/s[9]), 1/(1 + 690.0/s[36]), 1/(1 + 680.0/s[50]), 1/(1 + 180.0/s[9]), 1/(1 + 690.0/s[36]), 1/(1 + 850.0/s[50]), 1/(1 + 260.0/s[9]), 1/(1 + 100.0/s[9]), 1/(1 + 580.0/s[50])], [1/((1 + 590.0/s[1])*(1 + 1900.0/s[50])), 1/((1 + 470.0/s[1])*(1 + 1750.0/s[50])), 1/(1 + 4000.0/s[50])], [1/(1 + 37000.0/s[37])], [1/(1 + 5000.0/s[50]), 1/((1 + 1300.0/s[1])*(1 + 3800.0/s[50]))], [0, 1], [1/(1 + 1200.0/s[50])], [1/((1 + 1500.0/s[50])*(1 + 4000.0/s[9]))], [0, 1], [1/(1 + 78.0/s[9])], [1/(1 + 100.0/s[8]), 1/(1 + 4200.0/s[70])], [1/(1 + 115.2/s[9])], [1/((1 + 2400.0/s[1])*(1 + 420.0/s[46]))], [1/((1 + 6600.0/s[1])*(1 + 2200.0/s[51]))], [1/((1 + 1700.0/s[1])*(1 + 2700.0/s[89]))], [1/(1 + 430.0/s[9]), 1/(1 + 170.0/s[36]), 1/(1 + 50.0/s[9]), 1/(1 + 29.0/s[36]), 1/(1 + 44.0/s[9]), 1/(1 + 130.0/s[36]), 1/(1 + 240.0/s[9]), 1/(1 + 150.0/s[36])], [0, 1], [0, 1], [1/(1 + 300.0/s[12]), 1/(1 + 226.0/s[12]), 1/(1 + 127.0/s[12]), 1/(1 + 226.0/s[12]), 1/(1 + 304.0/s[12])], [1/(1 + 92.0/s[12]), 1/(1 + 45.0/s[12]), 1/(1 + 45.0/s[12])], [1/(1 + 9.7/s[12]), s[12]/(s[12] + 13.8095238095238*s[3] + 29)], [1/((1 + 700.0/s[4])*(1 + 20.0/s[63])), 1/((1 + 120.0/s[4])*(1 + 26.0/s[63])*(0.0303030303030303*s[63] + 1))], [1/(1 + 330.0/s[17])], [1/(1 + 320.0/s[36]), 1/(1 + 354.0/s[36]), s[9]**2.2/(s[9]**2.2 + 843721.833263995), s[88]**1.26/(s[88]**1.26 + 1217.22247621657), 1/(1 + 350.0/s[36])], [1/(1 + 220.0/s[19]), 1/(1 + 200.0/s[19]), 1/(1 + 200.0/s[19]), 1/(1 + 200.0/s[19]), 1/(1 + 190.0/s[19]), 1/(1 + 460.0/s[19]), 1/(1 + 970.0/s[19]), 1/(1 + 302.0/s[19])], [1/((1 + 81.4/s[29])*(1 + 13.0/s[64]))], [1/((1 + 96.5/s[29])*(1 + 5.8/s[64])), 1/((1 + 86.0/s[29])*(1 + 9.0/s[64])), 1/((1 + 21000.0/s[29])*(1 + 2000.0/s[64])), 1/(1 + 35.0/s[64]), 1/(1 + 35.0/s[64]), 1/(1 + 21.0/s[29]), 1/(1 + 9.0/s[64])], [s[29]**2.6*s[64]**2.2/((s[29]**2.6 + 10341.34234124)*(s[64]**2.2 + 39.2109092482337))], [0, 1], [0, 1], [1/(1 + 200.0/s[73]), 1/(1 + 200.0/s[73])], [0, 1], [1/(1 + 350.0/s[72]), 1/(1 + 350.0/s[72]), 1/(1 + 350.0/s[72])], [0, 1], [1/(1 + 640.0/s[72]), 1/(1 + 640.0/s[72])], [s[23]**1.5/(s[23]**1.5 + 536.186534705973)], [0, 1], [1/(1 + 640.0/s[24]), 1/(1 + 1930.0/s[24])], [1/(1 + 10.0/s[26])], [1/(1 + 2.7/s[0]), 1/(1 + 1120.0/s[9])], [0, 1], [1/(1 + 238.0/s[52]), 1/(1 + 160.0/s[52]), 1/(1 + 160.0/s[52])], [0, 1], [1/(1 + 230.0/s[69]), 1/(1 + 260.0/s[69]), 1/(1 + 260.0/s[69]), 1/(1 + 260.0/s[69]), 1/(1 + 260.0/s[69]), 1/(1 + 160.0/s[69]), 1/(1 + 150.0/s[69]), 1/(1 + 7800.0/s[69])], [1/(1 + 75.6/s[27])], [1/(1 + 1070.0/s[11]), 1/(1 + 1500.0/s[11])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 0.5/s[60])], [1/(1 + 2400.0/s[69]), 1/(1 + 96.0/s[69]), 1/(1 + 48.7/s[69])], [1/(1 + 960.0/s[29]), 1/(1 + 74.0/s[62]), 1/((1 + 510.0/s[29])*(1 + 800.0/s[62]))], [0, 1], [1/(1 + 20.0/s[31])], [1/(1 + 240.0/s[31]), 1/(1 + 170.0/s[31]), 1/(1 + 140.0/s[31])], [1/(1 + 70.0/s[31])], [1/(1 + 100.0/s[31])], [1/(1 + 2400.0/s[31]), 1/(1 + 2400.0/s[31])], [1/(1 + 15.4/s[31]), 1/(1 + 1.7/s[31]), 1/(1 + 20.0/s[31])], [1/((1 + 64.0/s[36])*(1 + 51.0/s[9]))], [0, 1], [1/(1 + 1800.0/s[9])], [0, 1], [1/(1 + 700.0/s[55])], [1/(1 + 600.0/s[33])], [1/(1 + 857.0/s[55])], [1/(1 + 620.0/s[33]), 1/(1 + 207.0/s[33])], [s[1]*s[2]/(s[1]*s[2] + 5800*s[1]*(s[1]/10200 + 1) + 1070*s[2])], [1/(1 + 412.0/s[15]), 1/(1 + 200.0/s[15]), 1/(1 + 200.0/s[15]), 1/(1 + 200.0/s[15])], [0, 1], [0, 1], [1/(1 + 45.0/s[9])], [1/((1 + 51.0/s[40])*(1 + 61.0/s[9]))], [1/(1 + 590.0/s[9])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 5900.0/s[35])], [0, 1], [1/((1 + 100.0/s[37])*(1 + 180.0/s[9])), 1/((1 + 200.0/s[37])*(1 + 100.0/s[9])), 1/((1 + 27.0/s[37])*(1 + 100.0/s[9]))], [1/(1 + 1670.0/s[36]), 1/(1 + 1700.0/s[36])], [0, 1], [1/(1 + 7300.0/s[36])], [1/(1 + 30600.0/s[36])], [0, 1], [1/((1 + 3300.0/s[37])*(1 + 200.0/s[9]))], [1/(1 + 2320.0/s[37])], [1/(1 + 18.4/s[61])], [1/(1 + 1200.0/s[37])], [0, 1], [0, 1], [0, 1], [1/((1 + 800.0/s[74])*(1 + 80.0/s[78])), 1/((1 + 300.0/s[74])*(1 + 15.0/s[78])), 1/((1 + 140.0/s[74])*(1 + 7.03/s[78])), 1/((1 + 140.0/s[74])*(1 + 7.0/s[78]))], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 60.0/s[75])], [0, 1], [1/(1 + 640.0/s[34])], [0, 1], [0, 1], [0, 1], [1/(1 + 50.0/s[14])], [1/((1 + 140.0/s[45])*(1 + 130.0/s[9])*(0.000144927536231884*s[45] + 1)), 1/(1 + 120.0/s[45])], [1/((1 + 1600.0/s[45])*(1 + 170.0/s[76])), 1/((1 + 380.0/s[45])*(1 + 280.0/s[76]))], [0, 1], [1/((1 + 60.0/s[47])*(1 + 2000.0/s[62]))], [1/(1 + 96.0/s[48]), 1/((1 + 320.0/s[48])*(1 + 340.0/s[70])), 1/(1 + 0.85/s[48])], [1/(1 + 3.4/s[65]), 1/(1 + 0.13/s[65]), 1/(1 + 0.13/s[65]), 1/(1 + 6.3/s[65])], [1/(1 + 14.0/s[12]), 1/(1 + 7.0/s[12])], [0, 1], [1/(1 + 195.0/s[12]), 1/(1 + 192.0/s[12])], [1/(1 + 40.5/s[80]), 1/(1 + 39.2/s[61])], [0, 1], [1/(1 + 5.0/s[64])], [0, 1], [0, 1], [1/(1 + 0.5/s[50]), 1/(1 + 5200.0/s[50]), 1/(1 + 4900.0/s[50])], [1/(1 + 360.0/s[32])], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 40.0/s[63])], [1/((1 + 3410.0/s[55])*(1 + 41.5/s[61]))], [1/(1 + 250.0/s[54]), 1/(1 + 49.0/s[54])], [1/(1 + 200.0/s[62])], [1/((1 + 250.0/s[32])*(1 + 10.0/s[59]))], [0, 1], [1/(1 + 200.0/s[28])], [0, 1], [1/(1 + 11.2/s[76])], [0, 1], [0, 1], [0, 1], [1/(1 + 45.0/s[44])], [1/(1 + 53.0/s[85]), 1/(1 + 27.0/s[85]), 1/(1 + 58.0/s[85]), 1/(1 + 150.0/s[85])], [1/(1 + 2000.0/s[62]), 1/(1 + 2500.0/s[9])], [1/(1 + 13.0/s[59])], [1/((1 + 70.0/s[57])*(1 + 100.0/s[88]))], [0, 1], [1/(1 + 50.0/s[18]), 1/(1 + 640.0/s[18])], [0, 1], [1/(1 + 143.1/s[9])], [0, 1], [0, 1], [0, 1], [1/(1 + 520.0/s[36])], [1/(1 + 1750.0/s[9])], [1/(1 + 115.0/s[9])], [0, 1], [0, 1], [0, 1], [1/(1 + 9.5/s[4])], [1/((1 + 32.7/s[14])*(1 + 311.7/s[5]))], [s[4]**1.3*s[70]/((s[4]**1.3 + 140.578933202162)*(s[70] + 2.1)), 1/(1 + 44.9/s[4])], [s[14]*s[5]**1.7/((s[14] + 67.2)*(s[5]**1.7 + 105247.615704737)), 1/((1 + 67.2/s[14])*(1 + 900.0/s[5]))], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 130.0/s[62]), 1/(1 + 103.0/s[62]), 1/(1 + 103.0/s[62])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 193.0/s[9])], [1/(1 + 5.4/s[33]), 1/(1 + 20.0/s[33]), 1/(1 + 4.0/s[33])], [1/(1 + 0.3/s[77]), 1/(1 + 1.3/s[77]), 1/(1 + 1.5/s[77])], [1/(1 + 4.8/s[59])], [1/(1 + 3000.0/s[28]), 1/(1 + 2000.0/s[28])], [0, 1], [1/(1 + 3100.0/s[71])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 500.0/s[49])], [0, 1], [0, 1], [1/(1 + 27.0/s[73])], [1/(1 + 26.7/s[73])], [1/(1 + 26.0/s[73])], [1/(1 + 0.035/s[13])], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 3.7/s[73])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/((1 + 260.9/s[69])*(1 + 4.62/s[79]))], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 69.1/s[88])], [1/(1 + 280.0/s[25])], [0, 1], [0, 1], [0, 1], [1/(1 + 12.0/s[21]), 1/(1 + 17.0/s[21])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 4800.0/s[74])], [1/(1 + 4000.0/s[74]), 1/(1 + 2670.0/s[74]), 1/(1 + 2670.0/s[74]), 1/(1 + 2670.0/s[74])], [0, 1], [1/(1 + 227.0/s[82]), 1/(1 + 227.0/s[82])], [0, 1], [1/(1 + 37.0/s[59])], [1/(1 + 339.0/s[41])], [0, 1], [0, 1], [0, 1], [1/(1 + 490.0/s[1])], [1/(1 + 220.0/s[9]), 1/(1 + 380.0/s[53])], [0, 1], [1/(1 + 1200.0/s[47])], [1/(1 + 1900.0/s[42])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/((1 + 2500.0/s[33])*(1 + 2700.0/s[50])), 1/(1 + 48.0/s[33])], [0, 1], [0, 1], [1/(1 + 101.4/s[73])], [0, 1], [1/((1 + 540.0/s[61])*(1 + 40000.0/s[74]))], [1/(1 + 7.1/s[66])], [0, 1], [1/(1 + 9.0/s[1]), 1/(1 + 32.0/s[1])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 790.0/s[22])], [1/(1 + 900.0/s[20])], [0, 1], [1/(1 + 110.0/s[59])], [0, 1], [0, 1], [1/(1 + 53.0/s[83])], [1/(1 + 1300.0/s[83])], [0, 1], [0, 1], [1/(1 + 20.0/s[9])], [0, 1], [1/(1 + 162.0/s[15])], [0, 1], [1/(1 + 2200.0/s[16])], [0, 1], [1/(1 + 1000.0/s[30])], [1/(1 + 2300.0/s[30])], [1/(1 + 52.0/s[59])], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 170.0/s[60]), 1/(1 + 65.6/s[60])], [0, 1], [0, 1], [0, 1], [1/(1 + 4.0/s[43]), 1/(1 + 4.0/s[43])], [1/(1 + 50.0/s[43])], [1/(1 + 49.0/s[43])], [1/(1 + 120.0/s[43])], [1/(1 + 3.4/s[17])], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 56.0/s[9])], [0, 1], [1/(1 + 58000.0/s[67]), 1/(1 + 58000.0/s[67]), 1/(1 + 59000.0/s[67])], [1/(1 + 840.0/s[39])], [1/(1 + 190.0/s[9])], [1/(1 + 560.0/s[62])], [0, 1], [0, 1], [0, 1], [0, 1], [1/(1 + 17.0/s[4])], [0, 1], [0, 1], [0, 1], [1/(1 + 544800.0/s[38]), 1/(1 + 285.0/s[62])], [0, 1], [0, 1], [0, 1], [1/(1 + 0.3/s[10]), 1/(1 + 200.0/s[9])], [1/(1 + 48.0/s[9]), 1/(1 + 90.0/s[9])], [0, 1], [0, 1], [1/((1 + 92.0/s[56])*(1 + 73.0/s[9])), 1/((1 + 110.0/s[56])*(1 + 83.0/s[9]))], [0, 1], [0, 1], [1/((1 + 200.0/s[4])*(1 + 1170.0/s[74]))], [1/((1 + 200.0/s[4])*(1 + 1170.0/s[74]))], [0, 1], [1/((1 + 4.0/s[14])*(1 + 250.0/s[77])*(1 + 70.0/s[9])), 1/((1 + 4.0/s[14])*(1 + 250.0/s[77])*(1 + 70.0/s[9])), 1/(1 + 141.0/s[77]), 1/(1 + 55.0/s[9]), 1/(1 + 58.0/s[14])], [1/(1 + 2.5/s[77]), 1/(1 + 2.0/s[77])], [0, 1], [1/(1 + 600.0/s[62])], [0, 1], [0, 1], [1/((1 + 270.0/s[62])*(1 + 6500.0/s[81]))], [1/(1 + 10000.0/s[81]), 1/(1 + 40000.0/s[81])], [0, 1], [0, 1], [0, 1], [1/(1 + 8600.0/s[15])], [0, 1], [0, 1], [0, 1], [1/(1 + 6.0/s[73])], [1/(1 + 17.0/s[73])], [1/((1 + 1300.0/s[1])*(1 + 320.0/s[84])), 1/(1 + 830.0/s[84]), 1/(1 + 320.0/s[84])], [1/((1 + 87.0/s[49])*(1 + 92.0/s[9])), 1/((1 + 48.0/s[49])*(1 + 130.0/s[9])), 1/((1 + 20.0/s[49])*(1 + 450.0/s[9]))], [0, 1], [s[85]**1.8/(s[85]**1.8 + 600)], [1/(1 + 1200.0/s[15])], [0, 1], [0, 1], [1/(1 + 820.0/s[85]), 1/(1 + 600.0/s[85])], [1/((1 + 1000.0/s[64])*(1 + 2500.0/s[85])), 1/((1 + 0.4/s[64])*(1 + 15.0/s[85])), 1/((1 + 0.84/s[64])*(1 + 36.0/s[85]))], [0, 1], [1/(1 + 360.0/s[86])], [0, 1], [0, 1], [1/(1 + 80.0/s[87])]]",
            "_set_solver_values": "METHOD:  Sets values to be used in the FBA solver. Attributes set: - :py:attr:`~.solver` - :py:attr:`~.kinetic_objective_weight` - :py:attr:`~.secretion_penalty_coeff` ",
            "aa_degradation_kms": "ndarray of length 21 and shape (21,)",
            "aa_enzymes": "ndarray of length 53 and shape (53,)",
            "aa_export_kms": "ndarray of length 21 and shape (21,)",
            "aa_exporter_names": "ndarray of length 14 and shape (14,)",
            "aa_forward_stoich": "ndarray of length 21 and shape (21, 21)",
            "aa_import_kis": "ndarray of length 21 and shape (21,)",
            "aa_importer_names": "ndarray of length 36 and shape (36,)",
            "aa_kcats_fwd": "ndarray of length 21 and shape (21,)",
            "aa_kcats_rev": "ndarray of length 21 and shape (21,)",
            "aa_kis": "ndarray of length 21 and shape (21,)",
            "aa_reverse_kms": "ndarray of length 21 and shape (21,)",
            "aa_reverse_stoich": "ndarray of length 21 and shape (21, 21)",
            "aa_supply_enzyme_conc_basal": "[2.83521862e-21 6.32310220e-22 4.82932676e-22 1.55943590e-22\n 2.40317280e-22 2.62641836e-23 1.83685134e-21 3.98887288e-22\n 4.99774583e-21 8.42423688e-22 1.76298332e-22 2.37034257e-21\n 1.60900955e-21 1.55943590e-22 0.00000000e+00 3.20094737e-22\n 7.28174490e-22 6.40517777e-22 1.31320918e-24 3.61132524e-24\n 5.08868557e-23 1.81879471e-22 3.00724902e-22 3.67698570e-22\n 3.97245777e-23 3.75577825e-22 2.95472065e-24 1.35260545e-22\n 3.97245777e-23 1.74164367e-21 6.88449912e-22 6.56932892e-22\n 7.39993372e-22 1.72358705e-22 8.63402205e-21 1.29351104e-21\n 2.69930147e-21 9.84906884e-25 1.48392637e-22 1.53645474e-22\n 1.01445409e-22 0.00000000e+00 8.89699219e-23 3.14612089e-21\n 0.00000000e+00 2.52792767e-23 1.41301308e-21 5.90944131e-24\n 6.46755521e-23 3.57849501e-23 1.05056734e-23 1.11951083e-22\n 7.01253702e-22] g",
            "aa_supply_enzyme_conc_with_aa": "[1.58455798e-22 1.96927392e-22 4.34242588e-22 1.35166481e-22\n 1.79828906e-23 4.56942302e-23 1.48535728e-21 6.86887460e-23\n 4.30395428e-21 2.32745773e-22 4.59890317e-23 1.28798769e-21\n 1.34016755e-21 1.09076550e-23 0.00000000e+00 1.65236232e-22\n 8.20432533e-22 2.50728663e-22 1.47400743e-24 2.35841188e-24\n 3.05119537e-23 1.53591574e-22 6.01395030e-23 1.00085104e-22\n 3.84715938e-23 3.50666367e-22 2.65321337e-24 1.04507126e-22\n 3.06593545e-23 1.50584599e-21 4.44708040e-22 2.99960511e-22\n 6.14218894e-22 1.40030705e-22 7.15822226e-21 1.30744459e-21\n 1.36935290e-22 1.03180520e-24 1.34282076e-22 1.27943845e-22\n 4.61364324e-23 0.00000000e+00 1.03180520e-23 2.61724759e-21\n 0.00000000e+00 2.32893173e-23 8.53450300e-23 5.01162525e-24\n 1.85724936e-23 3.36073693e-23 9.87584975e-24 6.63303342e-24\n 1.22490017e-22] g",
            "aa_supply_scaling": "METHOD:  Called during polypeptide_elongation process Determine amino acid supply rate scaling based on current amino acid concentrations. Args: aa_conc: internal concentration for each amino acid (ndarray[float]) aa_present: whether each amino acid is in the external environment or not (ndarray[bool]) Returns: Scaling for the supply of each amino acid with higher supply rate if >1, lower supply rate if <1 ",
            "aa_synthesis_pathway_adjustments": "EMPTY DICT",
            "aa_synthesis_pathways": "DICT of length 21 with STR, DICT key, value pairs.",
            "aa_to_exporters": "DICT of length 21 with STR, LIST key, value pairs.",
            "aa_to_exporters_matrix": "ndarray of length 21 and shape (21, 14)",
            "aa_to_importers": "DICT of length 21 with STR, LIST key, value pairs.",
            "aa_to_importers_matrix": "ndarray of length 21 and shape (21, 36)",
            "aa_to_index": "DICT of length 21 with STR, INT key, value pairs.",
            "aa_upstream_kms": "ndarray of length 21 and shape (21, 21)",
            "amino_acid_export": "METHOD:  Calculate the rate of amino acid export. Args: aa_transporters_counts: counts of each transporter aa_conc: concentrations of each amino acid with mol/volume units mechanistic_uptake: if true, the uptake is calculated based on transporters Returns: Rate of export for each amino acid (unitless but represents counts of amino acid per second) ",
            "amino_acid_export_kms": "LIST of length 7 of DICT types.",
            "amino_acid_import": "METHOD:  Calculate the rate of amino acid uptake. Args: aa_in_media: bool for each amino acid being present in current media dry_mass: current dry mass of the cell, with mass units internal_aa_conc: internal concentrations of amino acids aa_transporters_counts: counts of each transporter mechanistic_uptake: if true, the uptake is calculated based on transporters Returns: Rate of uptake for each amino acid (unitless but represents counts of amino acid per second) ",
            "amino_acid_synthesis": "METHOD:  Calculate the net rate of synthesis for amino acid pathways (can be negative with reverse reactions). Args: counts_per_aa_fwd: counts for enzymes in forward reactions for each amino acid counts_per_aa_rev: counts for enzymes in loss reactions for each amino acid aa_conc: concentrations of each amino acid with mol/volume units Returns: 3-element tuple containing - synthesis: net rate of synthesis for each amino acid pathway.  array is unitless but represents counts of amino acid per second - forward_fraction: saturated fraction for forward reactions - loss_fraction: saturated fraction for loss reactions .. note:: Currently does not match saturation terms used in calc_kcats since it assumes only a reverse or degradation KM exists for simpler calculations ",
            "amino_acid_uptake_rates": "DICT of length 19 with STR, DICT key, value pairs.",
            "base_reaction_ids": "LIST of length 2810 of STR types.",
            "catalysis_matrix_I": "ndarray of length 17979 and shape (17979,)",
            "catalysis_matrix_J": "ndarray of length 17979 and shape (17979,)",
            "catalysis_matrix_V": "ndarray of length 17979 and shape (17979,)",
            "catalyst_ids": "LIST of length 1562 of STR types.",
            "conc_dict": "DICT of length 172 with STR, UNUM key, value pairs.",
            "concentration_updates": {
                "_add_molecule_amounts": "METHOD: None",
                "_all_metabolite_ids": "SET of length 7591 of STR types.",
                "_exchange_flux_present": "METHOD:  Caches the presence of exchanges in each media condition based on exchange_data to set concentrations in concentrations_based_on_nutrients(). Args: exchange_data: dictionary of exchange data for all media conditions with keys::  {importUnconstrainedExchangeMolecules (dict[str, set[str]]):  exchange molecules (with location tag) for each media key  that do not have an upper bound on their flux,  importConstrainedExchangeMolecules (dict[str,  dict[str, float with mol/mass/time units]]): constrained  molecules (with location tag) for each media key with upper  bound flux constraints} Returns: Sets of molecules IDs (with location tags) that can be imported for each media ID ",
                "concentrations_based_on_nutrients": "METHOD: None",
                "default_concentrations_dict": "DICT of length 162 with STR, FLOAT64 key, value pairs.",
                "exchange_fluxes": "DICT of length 20 with STR, SET key, value pairs.",
                "linked_metabolites": "DICT of length 1 with STR, DICT key, value pairs.",
                "molecule_scale_factors": "DICT of length 21 with STR, FLOAT key, value pairs.",
                "molecule_set_amounts": "DICT of length 268 with STR, UNUM key, value pairs.",
                "relative_changes": "DICT of length 15 with STR, DICT key, value pairs.",
                "units": "1 mol"
            },
            "constraint_is_kcat_only": "ndarray of length 416 and shape (416,)",
            "constraints_to_disable": "LIST of length 20 of STR types.",
            "enzyme_to_amino_acid_fwd": "ndarray of length 53 and shape (53, 21)",
            "enzyme_to_amino_acid_rev": "ndarray of length 53 and shape (53, 21)",
            "exchange_constraints": "METHOD:  Called during Metabolism process Returns the homeostatic objective concentrations based on the current nutrients Returns levels for external molecules available to exchange based on the current nutrients ",
            "export_kcats_per_aa": "ndarray of length 21 and shape (21,)",
            "extract_kinetic_constraints": "METHOD:  Load and parse kinetic constraint information from raw_data Args: raw_data: knowledge base data sim_data: simulation data stoich: stoichiometry of metabolites for each reaction (if ``None``, data is loaded from ``raw_data`` and ``sim_data``):: {reaction ID: {metabolite ID with location tag: stoichiometry}} catalysts: enzyme catalysts for each reaction with known catalysts, likely a subset of reactions in ``stoich`` (if ``None``, data is loaded from ``raw_data`` and ``sim_data``:: {reaction ID: enzyme IDs with location tag} known_metabolites: metabolites with known concentrations Returns: Valid kinetic constraints for each reaction/enzyme pair:: {(reaction ID, enzyme with location tag): {  'kcat': kcat values (list[float]),  'saturation': saturation equations (list[str]) }} ",
            "extract_reactions": "METHOD:  Extracts reaction data from raw_data to build metabolism reaction network with stoichiometry, reversibility and enzyme catalysts. Args: raw_data: knowledge base data sim_data: simulation data Returns: 5-element tuple containing - base_rxn_ids: list of base reaction IDs from which reaction  IDs were derived from - reaction_stoich: stoichiometry of metabolites for each reaction::  {reaction ID: {metabolite ID with location tag: stoichiometry}} - reversible_reactions: reaction IDs for reactions that have a  reverse complement, does not have reverse tag - reaction_catalysts: enzyme catalysts for each reaction with known  catalysts, likely a subset of reactions in stoich::  {reaction ID: enzyme IDs with location tag} - rxn_id_to_base_rxn_id: mapping from reaction IDs to the IDs of  the base reactions they were derived from::  {reaction ID: base ID} ",
            "fraction_import_rate": "ndarray of length 21 and shape (21,)",
            "fraction_supply_rate": "ndarray of length 21 and shape (21,)",
            "get_aa_to_transporters_mapping_data": "METHOD:  Creates a dictionary that maps amino acids with their transporters. Based on this dictionary, it creates a correlation matrix with rows as AA and columns as transporters. Args: sim_data: simulation data export: if True, the parameters calculated are for mechanistic export instead of uptake Returns: 3-element tuple containing - aa_to_transporters: dictonary that maps aa to  transporters involved in transport reactions - aa_to_transporters_matrix: correlation matrix.  Columns correspond to transporter enzymes and rows to  amino acids - aa_transporters_names: names of all transporters ",
            "get_amino_acid_conc_conversion": "METHOD: None",
            "get_kinetic_constraints": "METHOD:  Allows for dynamic code generation for kinetic constraint calculation for use in Metabolism process. Inputs should be unitless but the order of magnitude should match the kinetics parameters (umol/L/s). If trying to pickle sim_data object after function has been called, _compiled_enzymes and _compiled_saturation might not be able to be pickled. See __getstate__(), __setstate__() comments on PR 111 to address. Returns np.array of floats of the kinetic constraint target for each reaction with kinetic parameters Args: enzymes: concentrations of enzymes associated with kinetic constraints (mol / volume units) substrates: concentrations of substrates associated with kinetic constraints (mol / volume units) Returns: Array of dimensions (n reactions, 3) where each row contains the min, mean and max kinetic constraints for each reaction with kinetic constraints (mol / volume / time units) ",
            "get_pathway_enzyme_counts_per_aa": "METHOD:  Get the counts of enzymes for forward and reverse reactions in the amino acid synthesis network based on all of the enzymes used in the network. Useful to get the counts to pass to amino_acid_synthesis() from counts based on self.aa_enzymes. Args: enzyme_counts: counts of all enzymes in the amino acid network Returns: 2-element tuple containing - counts_per_aa_fwd: counts of enzymes for the forward reaction  for each amino acid - counts_per_aa_rev: counts of enzymes for the reverse reaction  for each amino acid ",
            "import_kcats_per_aa": "ndarray of length 21 and shape (21,)",
            "kinetic_constraint_enzymes": "LIST of length 306 of STR types.",
            "kinetic_constraint_reactions": "LIST of length 416 of STR types.",
            "kinetic_constraint_substrates": "LIST of length 90 of STR types.",
            "kinetic_objective_weight": 1e-07,
            "kinetic_objective_weight_in_range": 0.01,
            "maintenance_reaction": "DICT of length 5 with STR, INT key, value pairs.",
            "match_reaction": "METHOD:  Matches a given reaction (rxn_to_match) to reactions that exist in stoich given that enz is known to catalyze the reaction and mets are reactants in the reaction. Can perform a fuzzy reaction match since rxn_to_match just needs to be part of the actual reaction name to match specific instances of a reaction. (eg. rxn_to_match=\"ALCOHOL-DEHYDROG-GENERIC-RXN\" can match \"ALCOHOL-DEHYDROG-GENERIC-RXN-ETOH/NAD//ACETALD/NADH/PROTON.30.\"). Args: stoich: stoichiometry of metabolites for each reaction:: {reaction ID: {metabolite ID with location tag: stoichiometry}} catalysts: enzyme catalysts for each reaction with known catalysts, likely a subset of reactions in stoich:: {reaction ID: enzyme IDs with location tag} rxn_to_match: reaction ID from kinetics to match to existing reactions enz: enzyme ID with location tag mets: metabolite IDs with no location tag from kinetics direction: reaction directionality, ``'forward'`` or ``'reverse'`` or ``None`` Returns: Matched reaction IDs in stoich ",
            "max_specific_import_rates": "ndarray of length 21 and shape (21,)",
            "metabolite_charge": "DICT of length 7591 with STR, INT key, value pairs.",
            "nutrients_to_internal_conc": "DICT of length 1 with STR, DICT key, value pairs.",
            "ppgpp_degradation_reaction": "PPGPPSYN-RXN",
            "ppgpp_reaction_metabolites": "LIST of length 7 of STR types.",
            "ppgpp_reaction_names": "LIST of length 2 of STR types.",
            "ppgpp_reaction_stoich": "ndarray of length 7 and shape (7, 2)",
            "ppgpp_synthesis_reaction": "GDPPYPHOSKIN-RXN",
            "reaction_catalysts": "DICT of length 8371 with STR, LIST key, value pairs.",
            "reaction_id_to_base_reaction_id": "DICT of length 9470 with STR, STR key, value pairs.",
            "reaction_stoich": "DICT of length 9449 with STR, DICT key, value pairs.",
            "reactions_with_catalyst": "LIST of length 8371 of STR types.",
            "secretion_penalty_coeff": 0.001,
            "set_mechanistic_export_constants": "METHOD:  Calls get_aa_to_transporters_mapping_data() for AA export, which calculates the total amount of export transporter counts per AA. Kcats are calculated using the same exchange rates as for uptake and transporter counts. Missing KMs are calculated based on present KMs. This is done by calculating the average factor for KMs compared to estimated concentration (av_factor = sum(KM / concentration) / n_aa_with_kms). ** KM = av_factor * concentration Args: sim_data: simulation data cell_specs: mapping from condition to calculated cell properties basal_container: average initial bulk molecule counts in the basal condition (structured Numpy array, see :ref:`bulk`) Attributes set: - :py:attr:`~.aa_to_exporters` - :py:attr:`~.aa_to_exporters_matrix` - :py:attr:`~.aa_exporter_names` - :py:attr:`~.aa_export_kms` - :py:attr:`~.export_kcats_per_aa` ",
            "set_mechanistic_supply_constants": "METHOD:  Sets constants to determine amino acid supply during translation. Used with amino_acid_synthesis() and amino_acid_import() during simulations but supply can alternatively be determined phenomologically. This approach is more detailed and should better respond to environmental changes and perturbations but has more variability related to gene expression and regulation. Args: sim_data: simulation data cell_specs: mapping from condition to calculated cell properties basal_container: average initial bulk molecule counts in the basal condition (structured Numpy array, see :ref:`bulk`) with_aa_container: average initial bulk molecule counts in the ``with_aa`` condition Sets class attributes: - :py:attr:`~.aa_enzymes` - :py:attr:`~.aa_kcats_fwd` - :py:attr:`~.aa_kcats_rev` - :py:attr:`~.aa_kis` - :py:attr:`~.aa_upstream_kms` - :py:attr:`~.aa_reverse_kms` - :py:attr:`~.aa_upstream_mapping` - :py:attr:`~.enzyme_to_amino_acid` - :py:attr:`~.aa_forward_stoich` - :py:attr:`~.aa_reverse_stoich` - :py:attr:`~.aa_import_kis` - :py:attr:`~.specific_import_rates` - :py:attr:`~.max_specific_import_rates` Assumptions: - Only one reaction is limiting in an amino acid pathway (typically the first and one with KI) and the kcat for forward or reverse directions will apply to all enzymes that can catalyze that step - kcat for reverse and degradation reactions is the same (each amino acid only has reverse or degradation at this point but that could change with modifications to the amino_acid_pathways flat file) TODO: - Search for new kcat/KM values in literature or use metabolism_kinetics.tsv - Consider multiple reaction steps - Include mulitple amino acid inhibition on importers (currently amino acids only inhibit their own import but some transporters import multiple amino acids and will be inhibited by all of the amino acids for the import of each amino acid) ",
            "set_mechanistic_uptake_constants": "METHOD:  Based on the matrix calculated in get_aa_to_transporters_mapping_data(), we calculate the total amount of transporter counts per AA. Args: sim_data: simulation data cell_specs: mapping from condition to calculated cell properties with_aa_container: average initial bulk molecule counts in the ``with_aa`` condition (structured Numpy array, see :ref:`bulk`) Attributes set: - :py:attr:`~.aa_to_importers` - :py:attr:`~.aa_to_importers_matrix` - :py:attr:`~.aa_importer_names` - :py:attr:`~.import_kcats_per_aa` - :py:attr:`~.export_kcats_per_aa` TODO: - Include external amino acid concentrations and KM values ",
            "set_phenomological_supply_constants": "METHOD:  Sets constants to determine amino acid supply during translation. Used with aa_supply_scaling() during simulations but supply can alternatively be determined mechanistically. This approach may require manually adjusting constants (fraction_supply_inhibited and fraction_supply_exported) but has less variability related to gene expression and regulation. Args: sim_data: simulation data Attributes set: - :py:attr:`~.KI_aa_synthesis` - :py:attr:`~.KM_aa_export` - :py:attr:`~.fraction_supply_rate` - :py:attr:`~.fraction_import_rate` Assumptions: - Each internal amino acid concentration in 'minimal_plus_amino_acids' media is not lower than in 'minimal' media TODO (Travis): Better handling of concentration assumption ",
            "solver": "glpk-linear",
            "specific_import_rates": "ndarray of length 21 and shape (21,)",
            "temperature_adjusted_kcat": "METHOD:  Args: kcat: enzyme turnover number(s) (1 / time) temp: temperature of measurement, defaults to 25 if '' Returns: Temperature adjusted kcat values, in units of 1/s ",
            "transport_reactions": "LIST of length 5615 of STR types.",
            "use_all_constraints": false
        },
        "replication": {
            "_build_elongation_rates": "METHOD: None",
            "_build_gene_data": "METHOD:  Build gene-associated simulation data from raw data. ",
            "_build_motifs": "METHOD:  Build simulation data associated with sequence motifs from raw_data. Coordinates of all motifs are calculated based on the given sequences of the genome and the motifs. ",
            "_build_replication": "METHOD:  Build replication-associated simulation data from raw data. ",
            "_build_sequence": "METHOD: None",
            "_build_sites": "METHOD:  Build simulation data associated with DNA sites from raw_data. ",
            "_get_complement_sequence": "METHOD:  Calculates the vector for a complement sequence of a DNA sequence given in vector form. ",
            "_get_motif_coordinates": "METHOD:  Finds the coordinates of all sequence motifs of a specific type. The coordinates are given as the positions of the midpoint of the motif relative to the oriC in base pairs. ",
            "_get_relative_coordinates": "METHOD:  Converts an array of genomic coordinates into coordinates relative to the origin of replication. ",
            "_n_nt_types": 4,
            "basal_elongation_rate": 967,
            "c_period": "2400.026887280248 s",
            "c_period_in_mins": 40.00044812133747,
            "d_period": "20 min",
            "d_period_in_mins": 20.0,
            "forward_complement_sequence": "ndarray of length 2324960 and shape (2324960,)",
            "forward_sequence": "ndarray of length 2324960 and shape (2324960,)",
            "gene_data": "ndarray of length 4747 and shape (4747,)",
            "genome_A_count": 1142742,
            "genome_C_count": 1180091,
            "genome_G_count": 1177437,
            "genome_T_count": 1141382,
            "genome_length": 4641652,
            "genome_sequence": {
                "Sequence": "AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGCTTCTGAACTGGTTACCTGCCGTGAGTAAATTAAAATTTTATTGACTTAGGTCACTAAATACTTTAACCAATATAGGCATAGCGCACAGACAGATAAAAATTACAGAGTACACAACATCCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGACGCGTACAGGAAACACAGAAAAAAGCCCGCACCTGACAGTGCGGGCTTTTTTTTTCGACCAAAGGTAACGAGGTAACAACCATGCGAGTGTTGAAGTTCGGCGGTACATCAGTGGCAAATGCAGAACGTTTTCTGCGTGTTGCCGATATTCTGGAAAGCAATGCCAGGCAGGGGCAGGTGGCCACCGTCCTCTCTGCCCCCGCCAAAATCACCAACCACCTGGTGGCGATGATTGAAAAAACCATTAGCGGCCAGGATGCTTTACCCAATATCAGCGATGCCGAACGTATTTTTGCCGAACTTTTGACGGGACTCGCCGCCGCCCAGCCGGGGTTCCCGCTGGCGCAATTGAAAACTTTCGTCGATCAGGAATTTGCCCAAATAAAACATGTCCTGCATGGCATTAGTTTGTTGGGGCAGTGCCCGGATAGCATCAACGCTGCGCTGATTTGCCGTGGCGAGAAAATGTCGATCGCCATTATGGCCGGCGTATTAGAAGCGCGCGGTCACAACGTTACTGTTATCGATCCGGTCGAAAAACTGCTGGCAGTGGGGCATTACCTCGAATCTACCGTCGATATTGCTGAGTCCACCCGCCGTATTGCGGCAAGCCGCATTCCGGCTGATCACATGGTGCTGATGGCAGGTTTCACCGCCGGTAATGAAAAAGGCGAACTGGTGGTGCTTGGACGCAACGGTTCCGACTACTCTGCTGCGGTGCTGGCTGCCTGTTTACGCGCCGATT..."
            },
            "genome_sequence_rc": {
                "Sequence": "GAAAAATACTTACTAAGGCGTTTTTTATTTGGTGATATTTTTTTCAATATCATGCAGCAAACGGTGCAACATTGCCGTGTCTCGTTGCTCTAAAAGCCCCAGGCGTTGTTGTAACCAGTCGACCAGTTTTATGTCATCTGCCACTGCCAGAGTCGTCAGCAATGTCATGGCTCGTTCGCGTAAAGCTTGCAGTTGATGTTGGTCTGCCGTTGCATCACTTTTCGCCGGTTGTTGTATTAATGTTGCTAATTGATAGCAATAGACCATCACCGCCTGCCCCAGATTGAGCGAAGGATAATCCGCCACCATCGGCACACCAGTAAGAACGTCAGCCAACGCTAACTCTTCGTTAGTCAACCCGGAATCTTCGCGACCAAACACCAGCGCGGCATGGCTCATCCATGAAGATTTTTCCTCTAACAGCGGCACCAGTTCAACTGGCGTGGCGTAGTAATGATATTTCGCCCGACTGCGCGCAGTGGTGGCGACAGTGAAATCGACATCGTGTAACGATTCAGCCAATGTCGGGAAAACTTTAATATTATCAATAATATCACCAGATCCATGTGCGACCCAGCGGGTGGCTGGCTCCAGGTGTGCCTGACTATCGACAATCCGCAGATCGCTAAACCCCATCGTTTTCATTGCCCGCGCCGCTGCCCCAATATTTTCTGCTCTGGCGGGTGCGACCAGAATAATCGTTATACGCATATTGCCACTCTTCTTGATCAAATAACCGCGAACCGGGTGATCACTGTCAACTTATTACGCGGTGCGAATTTACAAATTCTTAACGTAAGTCGCAGAAAAAGCCCTTTACTTAGCTTAAAAAAGGCTAAACTATTTCCTGACTGTACTAACGGTTGAGTTGTTAAAAAATGCTACATATCCTTCTGTTTACTTAGGATAATTTTATAAAAAATAAATCTCGACAATTGGATTCACCACGTTTATTAGTTGTATGATGCAACTAGTTGGATTATTAAAATAATGTGACGAA..."
            },
            "get_average_copy_number": "METHOD:  Calculates the average copy number of a gene throughout the cell cycle given the location of the gene in coordinates. Args: tau (float): expected doubling time in minutes coords (int or ndarray[int]): chromosome coordinates of genes Returns: float or ndarray[float] (matches length of coords): average copy number of each gene expected at a doubling time, tau ",
            "make_elongation_rates": "METHOD: None",
            "max_time_step": 1,
            "motif_coordinates": "DICT of length 1 with STR, NDARRAY key, value pairs.",
            "no_child_place_holder": -1,
            "oric_coordinate": 3925860,
            "replication_monomer_weights": "[5.18421957e-22 4.78527506e-22 5.44990582e-22 5.03455519e-22] g",
            "replication_sequences": "ndarray of length 4 and shape (4, 2325927)",
            "replichore_lengths": "ndarray of length 2 and shape (2,)",
            "reverse_complement_sequence": "ndarray of length 2316692 and shape (2316692,)",
            "reverse_sequence": "ndarray of length 2316692 and shape (2316692,)",
            "terc_coordinate": 1609168
        },
        "rna_decay": {
            "Km_convergence": "EMPTY LIST",
            "Km_first_order_decay": "ndarray of length 3376 and shape (3376,)",
            "_buildRnaDecayData": "METHOD: None",
            "endoRNase_ids": "LIST of length 9 of STR types.",
            "kcats": "[0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1] s",
            "km_loss_function": "METHOD:  Generates the functions used for estimating the per-RNA affinities (Michaelis-Menten constants) to the endoRNAses. The goal is to find a set of Michaelis-Menten constants such that the endoRNAse-mediated degradation under basal concentrations is consistent with the experimentally observed half-lives. If ``nonlinear`` is the rate of degradation predicted by Michaelis-Menten kinetics and ``linear`` is the rate of degradation from observed half-lives, we want:: nonlinear - linear = 0 In reality, there will be residuals ``R_aux = ``nonlinear - linear``. We care about the residuals after normalizing by the linear rate:: ``R = nonlinear / linear - 1``. In order to turn this into a minimization problem, we define the loss function as the squared sum of the residuals. Additionally, to ensure that all Km values are positive, the loss function accepts as input the logarithm of the final Km values and exponentiates them before calculating the residuals. The third-party package Autograd uses autodiff to calculate Jacobians for our loss function that can be used during minimization. Parameters ---------- vMax (float): The total endoRNase capacity, in units of amount per volume per time. rnaConc (np.ndarray): Concentrations of RNAs (amount per volume). kDeg (np.ndarray): Experimental degradation rates (per unit time). isEndoRnase (np.ndarray): Boolean array indicating endoRNase RNAs. Returns ------- tuple: A tuple containing the following functions: - **L** (*function*): The loss function to minimize. - **Lp** (*function*): The Jacobian of the loss function `L`. - **residual_f** (*function*): The residual error function. - **residual_aux_f** (*function*): The unnormalized residual error function. ",
            "sensitivity_analysis_alpha_regular_i_neg": "EMPTY DICT",
            "sensitivity_analysis_alpha_residual": "EMPTY DICT",
            "sensitivity_analysis_kcat": "EMPTY DICT",
            "sensitivity_analysis_kcat_res_ini": "EMPTY DICT",
            "sensitivity_analysis_kcat_res_opt": "EMPTY DICT",
            "stats_fit": "DICT of length 9 with STR, FLOAT64 key, value pairs."
        },
        "transcription": {
            "KD_RelA": "[0.31539423 0.54234625 0.18857738 0.15911241 0.07931178 0.30032665\n 0.28835774 0.29039986 0.07103289 0.32429601 0.47329241 0.3183431\n 0.41445708 0.11100811 0.25807276 0.24534692 0.3211185  0.02607457\n 0.26037508 0.0713877  0.40136855] umol",
            "KI_SpoT": "[24.26109484 41.71894224 14.50595248 12.23941636  6.1009063  23.10205001\n 22.18136448 22.33845114  5.46406848 24.94584712 36.40710832 24.48793041\n 31.88131423  8.53908538 19.85175109 18.87284038 24.7014227   2.00573587\n 20.02885265  5.49136153 30.87450396] umol",
            "_apply_rnaseq_correction": "METHOD:  Applies correction to RNAseq data for shorter genes as required when operon structure is included in the model. ",
            "_attenuation_rna_fold_changes": "ndarray of length 21 and shape (21, 17)",
            "_basal_rna_fractions": "DICT of length 3 with STR, FLOAT key, value pairs.",
            "_build_attenuation": "METHOD:  Load fold changes related to transcriptional attenuation. ",
            "_build_charged_trna": "METHOD:  Loads information and creates data structures necessary for charging of tRNA Note: Requires self.rna_data so can't be built in translation even if some data structures would be more appropriate there. ",
            "_build_cistron_data": "METHOD:  Build cistron-associated simulation data from raw data. Cistrons are sections of RNAs that encode for a specific polypeptide. A single RNA molecule may contain one or more cistrons. ",
            "_build_elongation_rates": "METHOD: None",
            "_build_mature_rna_data": "METHOD:  Build mature RNA-associated simulation data from raw data. ",
            "_build_new_gene_data": "METHOD:  Load baseline values for new gene expression in all simulations. ",
            "_build_oric_terc_coordinates": "METHOD:  Builds coordinates of oriC and terC that are used when calculating genomic positions of cistrons and RNAs relative to the origin ",
            "_build_ppgpp_regulation": "METHOD:  Determine which genes are regulated by ppGpp and store the fold change in expression associated with each gene. Attributes set: ppgpp_regulated_genes (ndarray[str]): cistron ID of regulated genes ppgpp_fold_changes (ndarray[float]): log2 fold change for each gene in ppgpp_regulated_genes _ppgpp_growth_parameters: parameters for interpolate.splev to estimate growth rate from ppGpp concentration ",
            "_build_rna_data": "METHOD:  Build RNA-associated simulation data from raw data. ",
            "_build_transcription": "METHOD:  Build transcription-associated simulation data from raw data. ",
            "_cistron_id_to_index": "DICT of length 4538 with STR_, INT key, value pairs.",
            "_cistron_is_rnaseq_covered": "ndarray of length 4538 and shape (4538,)",
            "_fit_ppgpp_fc": -0.5055417448942743,
            "_genome_length": 4641652,
            "_get_relative_coordinates": "METHOD:  Returns the genomic coordinates of a given gene coordinate relative to the origin of replication. ",
            "_normalize_ppgpp_expression": "METHOD:  Normalize both free and ppGpp bound expression values to 1. ",
            "_oric_coordinate": 3925860,
            "_ppgpp_expression_set": true,
            "_ppgpp_growth_parameters": "TUPLE of length 4 of STR types.",
            "_ppgpp_km_squared": 574.2026525051481,
            "_rna_id_to_index": "DICT of length 3277 with STR_, INT key, value pairs.",
            "_solve_ppgpp_km": "METHOD:  Solves for general expression rates for bound and free RNAP and a KM for ppGpp to RNAP based on global cellular measurements. Parameters are solved for at different doubling times using a gradient descent method to minimize the difference in expression of stable RNA compared to the measured RNA in a cell. Assumes a Hill coefficient of 2 for ppGpp binding to RNAP. Attributes set: _fit_ppgpp_fc (float): log2 fold change in stable RNA expression from a fast doubling time to a slow doubling time based on the rates of bound and free RNAP expression found _ppgpp_km_squared (float): squared and unitless KM value for to limit computation needed for fraction bound ppgpp_km (float with mol / volume units): KM for ppGpp binding to RNAP ",
            "_stoich_matrix_i": "ndarray of length 516 and shape (516,)",
            "_stoich_matrix_j": "ndarray of length 516 and shape (516,)",
            "_stoich_matrix_v": "ndarray of length 516 and shape (516,)",
            "_terc_coordinate": 1609168,
            "aa_from_synthetase": "ndarray of length 21 and shape (21, 22)",
            "aa_from_trna": "ndarray of length 21 and shape (21, 86)",
            "aa_kms": "[1.95000000e+02 6.95000000e+00 3.21500000e+01 6.80000000e+01\n 1.70666667e+01 1.09000000e+02 1.96000000e+02 1.60000000e+02\n 8.00000000e+00 3.94750000e+00 1.37857143e+01 7.35000000e+00\n 1.00000000e+02 1.08333333e+01 2.63333333e+02 6.40000000e+01\n 1.40333333e-01 1.46050000e+01 4.30000000e+00 1.00000000e+02\n 4.30000000e+00] umol",
            "active_rnap_footprint_size": "50 nucleotide",
            "adjust_polymerizing_ppgpp_expression": "METHOD:  Adjust ppGpp expression based on fit for ribosome and RNAP physiological constraints using least squares fit for 3 conditions with different growth rates/ppGpp. Modifies attributes: exp_ppgpp (ndarray[float]): expression for each gene when RNAP is bound to ppGpp, adjusted for necessary RNAP and ribosome expression, normalized to 1 exp_free (ndarray[float]): expression for each gene when RNAP is not bound to ppGpp, adjusted for necessary RNAP and ribosome expression, normalized to 1 Note: See docs/processes/transcription_regulation.pdf for a description of the math used in this section. TODO: fit for all conditions and not just those specified below? ",
            "adjust_ppgpp_expression_for_tfs": "METHOD:  Adjusts ppGpp regulated expression to get expression with and without ppGpp regulation to match in basal condition and taking into account the effect transcription factors will have. TODO: Should this not adjust polymerizing genes (adjusted_mask in adjust_polymerizing_ppgpp_expression) since they have already been adjusted for transcription factor effects? ",
            "attenuated_rna_ids": "ndarray of length 17 and shape (17,)",
            "attenuated_rna_indices": "ndarray of length 17 and shape (17,)",
            "attenuation_basal_prob_adjustments": "ndarray of length 17 and shape (17,)",
            "attenuation_k": "[[ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.         -0.41533655  0.          0.          0.\n  -0.41013773  0.          0.          0.          0.          0.\n  -0.41533655  0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.         -0.03835074  0.          0.          0.         -0.08003632\n   0.          0.          0.         -0.04068513 -0.05202361]\n [ 0.         -0.05929273  0.         -0.05767775 -0.05467851  0.\n   0.          0.         -0.06136913  0.          0.          0.\n   0.         -0.05790847  0.         -0.02733926 -0.00945915]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [-0.15810932  0.          0.          0.          0.         -0.15810932\n   0.          0.          0.          0.         -0.16234169  0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.         -0.09083416\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.         -1.19307329  0.          0.\n   0.          0.         -1.22410699  0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.          0.\n   0.          0.          0.          0.          0.        ]\n [ 0.         -0.04032541  0.          0.         -0.03701099  0.\n   0.          0.         -0.04170642  0.          0.          0.\n   0.         -0.03940474  0.         -0.04143021 -0.04253502]] umol",
            "attenuation_location": "DICT of length 17 with INT64, FLOAT64 key, value pairs.",
            "attenuation_readthrough": "DICT of length 51 with STR, NDARRAY key, value pairs.",
            "average_mRNA_cistron_half_life": "5.191214549938343 min",
            "calculate_attenuation": "METHOD:  Calculate constants for each attenuated gene. TODO: Calculate estimated charged tRNA concentration to use instead of all tRNA ",
            "charged_trna_names": "LIST of length 86 of STR types.",
            "charging_molecules": "LIST of length 196 of STR types.",
            "charging_stoich_matrix": "METHOD:  Creates stoich matrix from i, j, v arrays Returns 2D array with rows of metabolites for each tRNA charging reaction on the column ",
            "cistron_data": {
                "_field": "METHOD: None",
                "_validate": "METHOD: None",
                "fullArray": "METHOD: None",
                "fullUnits": "METHOD: None",
                "struct_array": "ndarray of length 4538 and shape (4538,)",
                "units": "DICT of length 18 with STR, NONETYPE key, value pairs."
            },
            "cistron_expression": "DICT of length 51 with STR, NDARRAY key, value pairs.",
            "cistron_id_to_rna_indexes": "METHOD:  Returns the indexes of transcription units containing the given RNA cistron given the ID of the cistron. ",
            "cistron_start_end_pos_in_tu": "DICT of length 5427 with TUPLE, TUPLE key, value pairs.",
            "cistron_tu_mapping_matrix": "SPARSE MATRIX with shape (4538, 3277)",
            "exp_free": "ndarray of length 3277 and shape (3277,)",
            "exp_ppgpp": "ndarray of length 3277 and shape (3277,)",
            "expression_from_ppgpp": "METHOD:  Calculates the expression of each gene at a given concentration of ppGpp. Args: ppgpp (float with or without mol / volume units): concentration of ppGpp, if unitless, should represent the concentration of PPGPP_CONC_UNITS Returns: ndarray[float]: normalized expression for each gene ",
            "fit_cistron_expression": "DICT of length 51 with STR, NDARRAY key, value pairs.",
            "fit_rna_expression": "METHOD:  Calculates the expression of RNA transcription units that best fits the given expression levels of cistrons using nonnegative least squares. ",
            "fit_trna_expression": "METHOD:  Calculates the expression of tRNA transcription units that best fits the given expression levels of tRNA cistrons using nonnegative least squares. ",
            "fraction_active_rnap_bound": 0.17172458793081588,
            "fraction_active_rnap_free": 0.36212365761075765,
            "fraction_rnap_bound_ppgpp": "METHOD:  Calculates the fraction of RNAP expected to be bound to ppGpp at a given concentration of ppGpp. Args: ppgpp (float with or without mol / volume units): concentration of ppGpp, if unitless, should represent the concentration of PPGPP_CONC_UNITS Returns: float: fraction of RNAP that will be bound to ppGpp ",
            "get_attenuation_stop_probabilities": "METHOD:  Calculate the probability of a transcript stopping early due to attenuation. TODO: Consider a maximum stop probability factor (eg can only attenuate up to 90% of RNAs) ",
            "get_rna_fractions": "METHOD:  Calculates expected RNA subgroup mass fractions based on ppGpp concentration. If ppGpp expression has not been set yet, uses default measured fractions. Args: ppgpp (float with or without mol / volume units): concentration of ppGpp, if unitless, should represent the concentration of PPGPP_CONC_UNITS Returns: dict[str, float]: mass fraction for each subgroup mass, values sum to 1 ",
            "get_rnap_active_fraction_from_ppGpp": "METHOD: None",
            "make_elongation_rates": "METHOD: None",
            "mature_rna_data": {
                "_field": "METHOD: None",
                "_validate": "METHOD: None",
                "fullArray": "METHOD: None",
                "fullUnits": "METHOD: None",
                "struct_array": "ndarray of length 99 and shape (99,)",
                "units": "DICT of length 11 with STR, NONETYPE key, value pairs."
            },
            "mature_rna_end_positions": "ndarray of length 99 and shape (99, 49)",
            "max_time_step": 1,
            "new_gene_expression_baselines": "DICT of length 5 with STR, FLOAT key, value pairs.",
            "operons": "LIST of length 2755 of TUPLE types.",
            "ppgpp_fold_changes": "ndarray of length 393 and shape (393,)",
            "ppgpp_km": "23.962526004266497 umol",
            "ppgpp_regulated_genes": "ndarray of length 393 and shape (393,)",
            "rRNA_cistron_tu_mapping_matrix": "SPARSE MATRIX with shape (22, 7)",
            "rRNA_indexes": "ndarray of length 7 and shape (7,)",
            "rnaPolymeraseElongationRateDict": "DICT of length 9 with STR, UNUM key, value pairs.",
            "rnaSynthProbFraction": "DICT of length 9 with STR, DICT key, value pairs.",
            "rnaSynthProbRProtein": "DICT of length 9 with STR, NDARRAY key, value pairs.",
            "rnaSynthProbRnaPolymerase": "DICT of length 9 with STR, NDARRAY key, value pairs.",
            "rna_data": {
                "_field": "METHOD: None",
                "_validate": "METHOD: None",
                "fullArray": "METHOD: None",
                "fullUnits": "METHOD: None",
                "struct_array": "ndarray of length 3277 and shape (3277,)",
                "units": "DICT of length 20 with STR, NONETYPE key, value pairs."
            },
            "rna_expression": "DICT of length 51 with STR, NDARRAY key, value pairs.",
            "rna_id_to_cistron_indexes": "METHOD:  Returns the indexes of cistrons that constitute the given transcription unit given the ID of the RNA transcription unit. ",
            "rna_id_to_evidence_codes": "DICT of length 3750 with STR, LIST key, value pairs.",
            "rna_maturation_degraded_nt_counts": "ndarray of length 49 and shape (49, 4)",
            "rna_maturation_enzyme_matrix": "ndarray of length 49 and shape (49, 3)",
            "rna_maturation_enzymes": "LIST of length 3 of STR types.",
            "rna_maturation_stoich_matrix": "SPARSE MATRIX with shape (99, 49)",
            "rna_synth_prob": "DICT of length 51 with STR, NDARRAY key, value pairs.",
            "rnapFractionActiveDict": "DICT of length 9 with STR, FLOAT64 key, value pairs.",
            "set_ppgpp_expression": "METHOD:  Called during the parca to determine expression of each transcription unit for ppGpp bound and free RNAP. Attributes set: exp_ppgpp (ndarray[float]): expression for each TU when RNAP is bound to ppGpp exp_free (ndarray[float]): expression for each TU when RNAP is not bound to ppGpp ",
            "set_ppgpp_kinetics_parameters": "METHOD: None",
            "stable_RNA_elongation_rate": 85.0,
            "synth_prob_from_ppgpp": "METHOD:  Calculates the synthesis probability of each gene at a given concentration of ppGpp. Args: ppgpp (float with mol / volume units): concentration of ppGpp copy_number (Callable[float, int]): function that gives the expected copy number given a doubling time and gene replication coordinate balanced_rRNA_prob (bool): if True, set synthesis probabilities  of rRNA promoters equal to one another Returns prob (ndarray[float]): normalized synthesis probability for each gene factor (ndarray[float]): factor to adjust expression to probability for each gene Note: copy_number should be sim_data.process.replication.get_average_copy_number but saving the function handle as a class attribute prevents pickling of sim_data without additional handling ",
            "synthetase_names": "LIST of length 22 of STR types.",
            "tRNA_cistron_tu_mapping_matrix": "SPARSE MATRIX with shape (86, 58)",
            "transcription_end_weight": "ndarray of length 1 and shape (1,)",
            "transcription_monomer_weights": "ndarray of length 4 and shape (4,)",
            "transcription_sequences": "ndarray of length 3277 and shape (3277, 15110)",
            "trna_kms": "[1.66666667 1.51       1.         0.37       0.80166667 0.16\n 0.2        1.         0.605      2.1        1.703      2.65\n 0.55       2.7        1.         0.56       0.775      0.48\n 1.         1.         0.008     ] umol",
            "uncharged_trna_names": "LIST of length 86 of STR types."
        },
        "transcription_regulation": {
            "_build_lookups": "METHOD:  Builds dictionaries for mapping transcription factor abbreviations to their RNA IDs, and to their active form. ",
            "abbr_to_active_id": "DICT of length 328 with STR, LIST key, value pairs.",
            "abbr_to_rna_id": "DICT of length 4122 with STR, STR key, value pairs.",
            "active_to_bound": "DICT of length 12 with STR, STR key, value pairs.",
            "basal_prob": "ndarray of length 3277 and shape (3277,)",
            "delta_prob": "DICT of length 4 with STR, NDARRAY key, value pairs.",
            "get_delta_prob_matrix": "METHOD:  Returns the delta probability matrix mapping the promoter binding effect of each TF to each gene. Args: dense: If True, returns a dense matrix, otherwise csr sparse ppgpp: If True, normalizes delta probabilities to be on the same scale as ppGpp normalized probabilities since delta_prob is calculated based on basal_prob which is not normalized to 1 Returns: delta_prob: matrix of probabilities changes expected with a TF binding to a promoter for each gene (n genes, m TFs) ",
            "p_promoter_bound_SKd": "METHOD:  Computes probability of a one-component transcription factor binding promoter. ",
            "p_promoter_bound_tf": "METHOD:  Computes probability of a transcription factor binding promoter. ",
            "target_tf": "DICT of length 2198 with STR, LIST key, value pairs.",
            "tf_ids": "LIST of length 23 of STR types.",
            "tf_to_gene_id": "DICT of length 23 with STR, STR key, value pairs.",
            "tf_to_tf_type": "DICT of length 23 with STR, STR key, value pairs."
        },
        "translation": {
            "_build_elongation_rates": "METHOD: None",
            "_build_monomer_data": "METHOD: None",
            "_build_translation": "METHOD: None",
            "_build_translation_efficiency": "METHOD: None",
            "active_ribosome_footprint_size": "24 nucleotide",
            "basal_elongation_rate": 22.0,
            "elongation_rates": "ndarray of length 4309 and shape (4309,)",
            "make_elongation_rates": "METHOD: None",
            "max_elongation_rate": 30.0,
            "max_time_step": 1,
            "monomer_data": {
                "_field": "METHOD: None",
                "_validate": "METHOD: None",
                "fullArray": "METHOD: None",
                "fullUnits": "METHOD: None",
                "struct_array": "ndarray of length 4309 and shape (4309,)",
                "units": "DICT of length 6 with STR, NONETYPE key, value pairs."
            },
            "n_monomers": 4309,
            "next_aa_pad": 1,
            "ribosomal_protein_indexes": "ndarray of length 54 and shape (54,)",
            "ribosomeElongationRateDict": "DICT of length 9 with STR, UNUM key, value pairs.",
            "ribosomeFractionActiveDict": "DICT of length 9 with STR, FLOAT64 key, value pairs.",
            "translation_efficiencies_by_monomer": "ndarray of length 4309 and shape (4309,)",
            "translation_end_weight": "ndarray of length 1 and shape (1,)",
            "translation_monomer_weights": "ndarray of length 21 and shape (21,)",
            "translation_sequences": "ndarray of length 4309 and shape (4309, 2370)"
        },
        "two_component_system": {
            "_buildComplexToMonomer": "METHOD:  Maps each complex to a dictionary that maps each subunit of the complex to its stoichiometry ",
            "_make_dependency_matrix": "METHOD:  Builds matrix mapping linearly independent molecules (ATP, histidine kinases, response regulators, and ligand-bound histidine kinases for positively oriented networks) to their dependents. ",
            "_make_derivative": "METHOD:  Creates symbolic representation of the ordinary differential equations and the Jacobian. Used during simulations. ",
            "_make_derivative_parca": "METHOD:  Creates symbolic representation of the ordinary differential equations and the Jacobian assuming ATP, ADP, Pi, water and protons are at steady state. Used in the parca. ",
            "_make_y_dy": "METHOD: None",
            "_populate_derivative_and_jacobian": "METHOD: Compile callable functions for computing the derivative and the Jacobian.",
            "_rates": "TUPLE of length 2 of FUNCTION types.",
            "_rates_jacobian": "TUPLE of length 2 of FUNCTION types.",
            "_stoichMatrixI": "ndarray of length 127 and shape (127,)",
            "_stoichMatrixJ": "ndarray of length 127 and shape (127,)",
            "_stoichMatrixV": "ndarray of length 127 and shape (127,)",
            "_stoich_matrix": "ndarray of length 41 and shape (41, 29)",
            "_stoich_matrix_mass": "ndarray of length 127 and shape (127,)",
            "active_to_inactive_tf": "DICT of length 7 with STR, STR key, value pairs.",
            "atp_reaction_reactant_mask": "ndarray of length 41 and shape (41,)",
            "balance_matrix": "ndarray of length 41 and shape (41, 29)",
            "complex_to_monomer": "DICT of length 18 with STR, DICT key, value pairs.",
            "dependency_matrix": "ndarray of length 41 and shape (41, 19)",
            "derivatives": "METHOD:  Calculate derivatives from stoichiometry and rates with argument order for solve_ivp. ",
            "derivatives_jacobian": "METHOD:  Calculate the jacobian of derivatives from stoichiometry and rates with argument order for solve_ivp. ",
            "derivatives_jacobian_jit": "METHOD:  Calculate the jacobian of derivatives from stoichiometry and rates with argument order for solve_ivp. ",
            "derivatives_jit": "METHOD:  Calculate derivatives from stoichiometry and rates with argument order for solve_ivp. ",
            "derivatives_parca": "METHOD: None",
            "derivatives_parca_jacobian": "METHOD: None",
            "derivatives_parca_jacobian_symbolic": "MutableDenseMatrix of length 1681 and shape (41, 41)",
            "derivatives_parca_symbolic": "MutableDenseMatrix of length 41 and shape (41, 1)",
            "get_monomers": "METHOD:  Returns subunits for a complex (or any ID passed). If the ID passed is already a monomer returns the monomer ID again with a stoichiometric coefficient of zero. ",
            "get_reaction_name": "METHOD:  Returns reaction name for a particular system. ",
            "independent_molecule_indexes": "ndarray of length 19 and shape (19,)",
            "independent_molecules": "ndarray of length 19 and shape (19,)",
            "independent_molecules_atp_index": 1,
            "independent_to_dependent_molecules": "DICT of length 18 with STR, STR key, value pairs.",
            "mass_balance": "METHOD:  Sum along the columns of the massBalance matrix to check for reaction mass balance ",
            "mass_matrix": "METHOD:  Builds stoichiometry mass matrix Rows: molecules Columns: reactions Values: molecular mass ",
            "molecule_names": "ndarray of length 41 and shape (41,)",
            "molecule_types": "ndarray of length 41 and shape (41,)",
            "molecules_to_next_time_step": "METHOD:  Calculates the changes in the counts of molecules in the next timestep by solving an initial value ODE problem. Args: moleculeCounts (1d ndarray, ints): current counts of molecules involved in the ODE cellVolume (float): current volume of cell nAvogadro (float): Avogadro's number timeStepSec (float): current length of timestep in seconds random_state (RandomState object): process random state method (str): name of the ODE method to use min_time_step (int): if not None, timeStepSec will be scaled down until it is below min_time_step if negative counts are encountered jit (bool): if True, use the jit compiled version of derivatives functions methods_tried (Optional[Set[str]]): methods for the solver that have already been tried Returns: moleculesNeeded (1d ndarray, ints): counts of molecules that need to be consumed allMoleculesChanges (1d ndarray, ints): expected changes in molecule counts after timestep ",
            "molecules_to_ss": "METHOD:  Calculates the changes in the counts of molecules as the system reaches steady state Args: moleculeCounts: current counts of molecules involved in the ODE cellVolume: current volume of cell nAvogadro: Avogadro's number timeStepSec: current length of timestep (set to large number) Returns: moleculesNeeded: counts of molecules that need to be consumed allMoleculesChanges: expected changes in molecule counts after timestep ",
            "rates_fwd": "ndarray of length 29 and shape (29,)",
            "rates_rev": "ndarray of length 29 and shape (29,)",
            "rxn_ids": "LIST of length 29 of STR types.",
            "stoich_matrix": "METHOD:  Builds stoichiometry matrix Rows: molecules Columns: reactions Values: reaction stoichiometry ",
            "stoich_matrix_monomers": "METHOD:  Builds stoichiometry matrix for monomers (complex subunits) Rows: molecules (complexes and monomers) Columns: complexes Values: monomer stoichiometry ",
            "symbolic_rates": "MutableDenseMatrix of length 29 and shape (29, 1)",
            "symbolic_rates_jacobian": "MutableDenseMatrix of length 1189 and shape (29, 41)"
        }
    },
    "relation": {
        "_build_RNA_to_tf_mapping": "METHOD:  Builds a dictionary that maps RNA IDs to a list of all transcription factor IDs that regulate the given RNA. All TFs that target any of the constituent cistrons in the RNA are added to each list. ",
        "_build_cistron_to_monomer_mapping": "METHOD:  Build a vector that can map vectors that describe a property for RNA cistrons into a vector that describes the same property for the corresponding monomers if used as an index array. Assumes that each monomer maps to a single RNA cistron (A single RNA can map to multiple monomers). e.g. monomer_property = RNA_cistron_property[ sim_data.relation.cistron_to_monomer_mapping] ",
        "_build_monomer_to_mRNA_cistron_mapping": "METHOD:  Builds a sparse matrix that can map vectors that describe a property for protein monomers into a vector that describes the same property for the corresponding mRNA cistrons if multiplied to the right of the original vector. The transformed property must be additive (i.e. if two proteins map to the same cistron, the values given for the two proteins are added to yield a value for the cistron). The full matrix can be returned by calling monomer_to_mRNA_cistron_mapping(). ",
        "_build_monomer_to_tu_mapping": "METHOD:  Builds a dictionary that maps monomer IDs to a list of all transcription unit IDs that the monomer can be translated from. ",
        "_build_tf_to_RNA_mapping": "METHOD:  Builds a dictionary that maps transcription factor IDs to a list of all RNA IDs that are targeted by the given TF. All RNA transcription units that contain any of the cistrons regulated by the TF are added to each list. ",
        "_monomer_to_mRNA_cistron_mapping_i": "LIST of length 4309 of INT types.",
        "_monomer_to_mRNA_cistron_mapping_j": "LIST of length 4309 of INT types.",
        "_monomer_to_mRNA_cistron_mapping_shape": "TUPLE of length 2 of INT types.",
        "_monomer_to_mRNA_cistron_mapping_v": "LIST of length 4309 of INT types.",
        "cistron_to_monomer_mapping": "ndarray of length 4309 and shape (4309,)",
        "monomer_index_to_tu_indexes": "DICT of length 4309 with INT, NDARRAY key, value pairs.",
        "monomer_to_mRNA_cistron_mapping": "METHOD:  Returns the full version of the sparse matrix built by _build_monomer_to_mRNA_cistron_mapping(). e.g. mRNA_property = sim_data.relation.monomer_to_mRNA_cistron_mapping().T.dot( monomer_property) ",
        "rna_id_to_regulating_tfs": "DICT of length 3277 with STR_, LIST key, value pairs.",
        "tf_id_to_target_RNAs": "DICT of length 145 with STR, LIST key, value pairs."
    },
    "stable_rrna": false,
    "submass_name_to_index": "DICT of length 9 with STR, INT key, value pairs.",
    "tf_to_active_inactive_conditions": "DICT of length 23 with STR, DICT key, value pairs.",
    "tf_to_direction": "DICT of length 145 with STR, DICT key, value pairs.",
    "tf_to_fold_change": "DICT of length 145 with STR, DICT key, value pairs.",
    "translation_supply_rate": "DICT of length 9 with STR, UNUM key, value pairs."
}
